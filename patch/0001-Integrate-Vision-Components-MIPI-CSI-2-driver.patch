From 8578f2de588e107f211fd8a0f6f32b8480a6e39f Mon Sep 17 00:00:00 2001
From: Peter Martienssen <peter.martienssen@liquify-consulting.de>
Date: Tue, 18 Jul 2023 17:17:39 +0200
Subject: [PATCH] Integrate Vision Components MIPI CSI-2 driver

---
 arch/arm64/configs/imx8_vc_mipi.config |    1 +
 drivers/media/i2c/Kconfig              |   12 +
 drivers/media/i2c/Makefile             |    1 +
 drivers/media/i2c/vc_mipi_camera.c     |  569 ++++++++
 drivers/media/i2c/vc_mipi_core.c       | 1637 ++++++++++++++++++++++++
 drivers/media/i2c/vc_mipi_core.h       |  242 ++++
 drivers/media/i2c/vc_mipi_modules.c    |  703 ++++++++++
 drivers/media/i2c/vc_mipi_modules.h    |   29 +
 8 files changed, 3194 insertions(+)
 create mode 100644 arch/arm64/configs/imx8_vc_mipi.config
 create mode 100755 drivers/media/i2c/vc_mipi_camera.c
 create mode 100755 drivers/media/i2c/vc_mipi_core.c
 create mode 100755 drivers/media/i2c/vc_mipi_core.h
 create mode 100644 drivers/media/i2c/vc_mipi_modules.c
 create mode 100644 drivers/media/i2c/vc_mipi_modules.h

diff --git a/arch/arm64/configs/imx8_vc_mipi.config b/arch/arm64/configs/imx8_vc_mipi.config
new file mode 100644
index 000000000000..90fac50a2837
--- /dev/null
+++ b/arch/arm64/configs/imx8_vc_mipi.config
@@ -0,0 +1 @@
+CONFIG_VIDEO_VC_MIPI=y
diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 5b8f2a06b8af..d150c97ea233 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -852,6 +852,18 @@ config VIDEO_IMX355
 	  To compile this driver as a module, choose M here: the
 	  module will be called imx355.
 
+config VIDEO_VC_MIPI
+	tristate "Vision Components MIPI CSI-2 sensor support"
+	depends on GPIOLIB && I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	depends on V4L2_FWNODE
+	help
+	  This is a Video4Linux2 sensor driver for Vision Components
+	  MIPI CSI-2 cameras.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vc-mipi-cam.
+
 config VIDEO_OV2640
 	tristate "OmniVision OV2640 sensor support"
 	depends on VIDEO_V4L2 && I2C
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index a7c43e901a76..9ba9dc1e5e76 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -121,6 +121,7 @@ obj-$(CONFIG_VIDEO_IMX274)	+= imx274.o
 obj-$(CONFIG_VIDEO_IMX290)	+= imx290.o
 obj-$(CONFIG_VIDEO_IMX319)	+= imx319.o
 obj-$(CONFIG_VIDEO_IMX355)	+= imx355.o
+obj-$(CONFIG_VIDEO_VC_MIPI)	+= vc_mipi_camera.o vc_mipi_core.o vc_mipi_modules.o
 obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
 rdacm20-camera_module-objs	:= rdacm20.o max9271.o
 obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20-camera_module.o
diff --git a/drivers/media/i2c/vc_mipi_camera.c b/drivers/media/i2c/vc_mipi_camera.c
new file mode 100755
index 000000000000..0056e41220ac
--- /dev/null
+++ b/drivers/media/i2c/vc_mipi_camera.c
@@ -0,0 +1,569 @@
+#include "vc_mipi_core.h"
+#include <linux/module.h>
+#include <linux/gpio/consumer.h>
+#include <linux/pm_runtime.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-fwnode.h>
+
+#define VERSION "0.1.0"
+
+struct vc_device {
+        struct v4l2_subdev sd;
+        struct v4l2_ctrl_handler ctrl_handler;
+        struct media_pad pad;
+        // struct gpio_desc *power_gpio;
+        int power_on;
+        struct mutex mutex;
+
+        struct vc_cam cam;
+};
+
+static inline struct vc_device *to_vc_device(struct v4l2_subdev *sd)
+{
+        return container_of(sd, struct vc_device, sd);
+}
+
+static inline struct vc_cam *to_vc_cam(struct v4l2_subdev *sd)
+{
+        struct vc_device *device = to_vc_device(sd);
+        return &device->cam;
+}
+
+
+// --- v4l2_subdev_core_ops ---------------------------------------------------
+
+static void vc_set_power(struct vc_device *device, int on)
+{
+        struct device *dev = &device->cam.ctrl.client_sen->dev;
+
+        if (device->power_on == on)
+                return;
+
+        vc_dbg(dev, "%s(): Set power: %s\n", __func__, on ? "on" : "off");
+
+        // if (device->power_gpio)
+	// 	gpiod_set_value_cansleep(device->power_gpio, on);
+        
+        // if (on == 1) {
+        //         vc_core_wait_until_device_is_ready(&device->cam, 1000);
+        // }
+        device->power_on = on;
+}
+
+static int vc_sd_s_power(struct v4l2_subdev *sd, int on)
+{
+        struct vc_device * device = to_vc_device(sd);
+
+        mutex_lock(&device->mutex);
+
+        vc_set_power(to_vc_device(sd), on);
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+static int __maybe_unused vc_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_state *state = &device->cam.state;
+
+        vc_dbg(dev, "%s()\n", __func__);
+
+	mutex_lock(&device->mutex);
+
+	if (state->streaming)
+		vc_sen_stop_stream(&device->cam);
+
+        vc_set_power(device, 0);
+
+	mutex_unlock(&device->mutex);
+
+	return 0;
+}
+
+static int __maybe_unused vc_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+        struct vc_device *device = to_vc_device(sd);
+
+        vc_dbg(dev, "%s()\n", __func__);
+
+	mutex_lock(&device->mutex);
+
+        vc_set_power(device, 1);
+
+	mutex_unlock(&device->mutex);
+
+	return 0;
+}
+
+static int vc_sd_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *control)
+{
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        switch (control->id) {
+        case V4L2_CID_EXPOSURE:
+                return vc_sen_set_exposure(cam, control->value);
+
+        case V4L2_CID_GAIN:
+                return vc_sen_set_gain(cam, control->value);
+
+        case V4L2_CID_BLACK_LEVEL:
+                return vc_sen_set_blacklevel(cam, control->value);
+
+        case V4L2_CID_TRIGGER_MODE:
+                return vc_mod_set_trigger_mode(cam, control->value);
+
+        case V4L2_CID_FLASH_MODE:
+                return vc_mod_set_io_mode(cam, control->value);
+
+        case V4L2_CID_FRAME_RATE:
+                return vc_core_set_framerate(cam, control->value);
+
+        case V4L2_CID_SINGLE_TRIGGER:
+                return vc_mod_set_single_trigger(cam);
+
+        default:
+                vc_warn(dev, "%s(): Unkown control 0x%08x\n", __func__, control->id);
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+// --- v4l2_subdev_video_ops ---------------------------------------------------
+
+static int vc_sd_s_stream(struct v4l2_subdev *sd, int enable)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct vc_state *state = &cam->state;
+        struct device *dev = sd->dev;
+        int ret = 0;
+
+        vc_dbg(dev, "%s(): Set streaming: %s\n", __func__, enable ? "on" : "off");
+
+        if (state->streaming == enable)
+		return 0;
+
+        mutex_lock(&device->mutex);
+        if (enable) {
+                ret = pm_runtime_get_sync(dev);
+                if (ret < 0) {
+			pm_runtime_put_noidle(dev);
+			mutex_unlock(&device->mutex);
+			return ret;
+		}
+
+                ret = vc_sen_start_stream(cam);
+                if (ret) {
+                        enable = 0;
+                        vc_sen_stop_stream(cam);
+                        pm_runtime_mark_last_busy(dev);
+	                pm_runtime_put_autosuspend(dev);
+                }
+
+        } else {
+                vc_sen_stop_stream(cam);
+                pm_runtime_mark_last_busy(dev);
+                pm_runtime_put_autosuspend(dev);
+        }
+
+        state->streaming = enable;
+        mutex_unlock(&device->mutex);
+
+        return ret;
+}
+
+// --- v4l2_subdev_pad_ops ---------------------------------------------------
+
+static int vc_sd_get_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg, struct v4l2_subdev_format *format)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct v4l2_mbus_framefmt *mf = &format->format;
+        struct vc_frame* frame = NULL;
+
+        mutex_lock(&device->mutex);
+
+        mf->code = vc_core_get_format(cam);
+        frame = vc_core_get_frame(cam);
+        mf->width = frame->width;
+        mf->height = frame->height;
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+static int vc_sd_set_fmt(struct v4l2_subdev *sd, struct v4l2_subdev_pad_config *cfg, struct v4l2_subdev_format *format)
+{
+        struct vc_device *device = to_vc_device(sd);
+        struct vc_cam *cam = to_vc_cam(sd);
+        struct v4l2_mbus_framefmt *mf = &format->format;
+        int reset = 0;
+        int ret = 0;
+
+        mutex_lock(&device->mutex);
+
+        vc_core_set_format(cam, mf->code);
+        vc_core_set_frame(cam, 0, 0, mf->width, mf->height);
+
+        ret  = vc_mod_set_mode(cam, &reset);
+	ret |= vc_sen_set_roi(cam);
+        if (!ret && reset) {
+                ret |= vc_sen_set_exposure(cam, cam->state.exposure);
+                ret |= vc_sen_set_gain(cam, cam->state.gain);
+                ret |= vc_sen_set_blacklevel(cam, cam->state.blacklevel);
+        }
+        
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+// --- v4l2_ctrl_ops ---------------------------------------------------
+
+int vc_ctrl_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+        struct vc_device *device = container_of(ctrl->handler, struct vc_device, ctrl_handler);
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct v4l2_control control;
+
+        // V4L2 controls values will be applied only when power is already up
+	if (!pm_runtime_get_if_in_use(&client->dev))
+		return 0;
+
+        mutex_lock(&device->mutex);
+
+        control.id = ctrl->id;
+        control.value = ctrl->val;
+        vc_sd_s_ctrl(&device->sd, &control);
+
+        mutex_unlock(&device->mutex);
+
+        return 0;
+}
+
+
+
+// *** Initialisation *********************************************************
+
+// static void vc_setup_power_gpio(struct vc_device *device)
+// {
+//         struct device *dev = &device->cam.ctrl.client_sen->dev;
+
+//         device->power_gpio = devm_gpiod_get_optional(dev, "power", GPIOD_OUT_HIGH);
+//         if (IS_ERR(device->power_gpio)) {
+//                 vc_err(dev, "%s(): Failed to setup power-gpio\n", __func__);
+//                 device->power_gpio = NULL;
+//         }
+// }
+
+static int vc_check_hwcfg(struct vc_cam *cam, struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint ep_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY
+	};
+	int ret = -EINVAL;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "Endpoint node not found!\n");
+		return -EINVAL;
+	}
+
+	if (v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep_cfg)) {
+		dev_err(dev, "Could not parse endpoint!\n");
+		goto error_out;
+	}
+
+        /* Set and check the number of MIPI CSI2 data lanes */
+	ret = vc_core_set_num_lanes(cam, ep_cfg.bus.mipi_csi2.num_data_lanes);;
+
+error_out:
+	v4l2_fwnode_endpoint_free(&ep_cfg);
+	fwnode_handle_put(endpoint);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops vc_core_ops = {
+        .s_power = vc_sd_s_power,
+};
+
+static const struct v4l2_subdev_video_ops vc_video_ops = {
+        .s_stream = vc_sd_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops vc_pad_ops = {
+        .get_fmt = vc_sd_get_fmt,
+        .set_fmt = vc_sd_set_fmt,
+};
+
+static const struct v4l2_subdev_ops vc_subdev_ops = {
+        .core = &vc_core_ops,
+        .video = &vc_video_ops,
+        .pad = &vc_pad_ops,
+};
+
+static const struct v4l2_ctrl_ops vc_ctrl_ops = {
+        .s_ctrl = vc_ctrl_s_ctrl,
+};
+
+static int vc_ctrl_init_ctrl(struct vc_device *device, struct v4l2_ctrl_handler *hdl, int id, struct vc_control* control) 
+{
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct device *dev = &client->dev;
+        struct v4l2_ctrl *ctrl;
+
+        ctrl = v4l2_ctrl_new_std(&device->ctrl_handler, &vc_ctrl_ops, id, control->min, control->max, 1, control->def);
+        if (ctrl == NULL) {
+                vc_err(dev, "%s(): Failed to init 0x%08x ctrl\n", __func__, id);
+                return -EIO;
+        }
+
+        return 0;
+}
+
+static int vc_ctrl_init_custom_ctrl(struct vc_device *device, struct v4l2_ctrl_handler *hdl, const struct v4l2_ctrl_config *config) 
+{
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct device *dev = &client->dev;
+        struct v4l2_ctrl *ctrl;
+
+        ctrl = v4l2_ctrl_new_custom(&device->ctrl_handler, config, NULL);
+        if (ctrl == NULL) {
+                vc_err(dev, "%s(): Failed to init 0x%08x ctrl\n", __func__, config->id);
+                return -EIO;
+        }
+
+        return 0;
+}
+
+static const struct v4l2_ctrl_config ctrl_trigger_mode = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_TRIGGER_MODE,
+        .name = "Trigger Mode",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_SLIDER,
+        .min = 0,
+        .max = 7,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_flash_mode = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_FLASH_MODE,
+        .name = "Flash Mode",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_SLIDER,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_frame_rate = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_FRAME_RATE,
+        .name = "Frame Rate",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_SLIDER,
+        .min = 0,
+        .max = 1000000,
+        .step = 1,
+        .def = 0,
+};
+
+static const struct v4l2_ctrl_config ctrl_single_trigger = {
+        .ops = &vc_ctrl_ops,
+        .id = V4L2_CID_SINGLE_TRIGGER,
+        .name = "Single Trigger",
+        .type = V4L2_CTRL_TYPE_INTEGER,
+        .flags = V4L2_CTRL_FLAG_SLIDER,
+        .min = 0,
+        .max = 1,
+        .step = 1,
+        .def = 0,
+};
+
+static int vc_sd_init(struct vc_device *device)
+{
+        struct i2c_client *client = device->cam.ctrl.client_sen;
+        struct device *dev = &client->dev;
+        int ret;
+
+        // Initializes the subdevice
+        v4l2_i2c_subdev_init(&device->sd, client, &vc_subdev_ops);
+
+        // Initialize the handler
+        ret = v4l2_ctrl_handler_init(&device->ctrl_handler, 3);
+        if (ret) {
+                vc_err(dev, "%s(): Failed to init control handler\n", __func__);
+                return ret;
+        }
+        // Hook the control handler into the driver
+        device->sd.ctrl_handler = &device->ctrl_handler;
+
+        // Add controls
+        ret |= vc_ctrl_init_ctrl(device, &device->ctrl_handler, V4L2_CID_EXPOSURE, &device->cam.ctrl.exposure);
+        ret |= vc_ctrl_init_ctrl(device, &device->ctrl_handler, V4L2_CID_GAIN, &device->cam.ctrl.gain);
+        ret |= vc_ctrl_init_ctrl(device, &device->ctrl_handler, V4L2_CID_BLACK_LEVEL, &device->cam.ctrl.blacklevel);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_trigger_mode);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_flash_mode);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_frame_rate);
+        ret |= vc_ctrl_init_custom_ctrl(device, &device->ctrl_handler, &ctrl_single_trigger);
+
+        return 0;
+}
+
+static int vc_link_setup(struct media_entity *entity, const struct media_pad *local, const struct media_pad *remote,
+                         __u32 flags)
+{
+        return 0;
+}
+
+static const struct media_entity_operations vc_sd_media_ops = {
+        .link_setup = vc_link_setup,
+};
+
+static int vc_probe(struct i2c_client *client)
+{
+        struct device *dev = &client->dev;
+        struct vc_device *device;
+        struct vc_cam *cam;
+        int ret;
+
+        device = devm_kzalloc(dev, sizeof(*device), GFP_KERNEL);
+        if (!device)
+                return -ENOMEM;
+        
+        cam = &device->cam;
+        cam->ctrl.client_sen = client;
+
+        // vc_setup_power_gpio(device);
+        vc_set_power(device, 1);
+
+        ret = vc_core_init(cam, client);
+        if (ret)
+                goto error_power_off;
+
+        ret = vc_check_hwcfg(cam, dev);
+	if (ret)
+		goto error_power_off;
+
+        mutex_init(&device->mutex);
+        ret = vc_sd_init(device);
+        if (ret)
+                goto error_handler_free;
+
+        device->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+        device->pad.flags = MEDIA_PAD_FL_SOURCE;
+        device->sd.entity.ops = &vc_sd_media_ops;
+        device->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+        ret = media_entity_pads_init(&device->sd.entity, 1, &device->pad);
+        if (ret)
+                goto error_handler_free;
+
+        ret = v4l2_async_register_subdev_sensor_common(&device->sd);
+        if (ret)
+                goto error_media_entity;
+
+        pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_set_autosuspend_delay(dev, 2000);
+	pm_runtime_use_autosuspend(dev);
+        pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+
+        return 0;
+
+error_media_entity:
+        media_entity_cleanup(&device->sd.entity);
+
+error_handler_free:
+        v4l2_ctrl_handler_free(&device->ctrl_handler);
+        mutex_destroy(&device->mutex);
+
+error_power_off:
+        pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_noidle(dev);
+        vc_set_power(device, 0);
+        return ret;
+}
+
+static int vc_remove(struct i2c_client *client)
+{
+        struct v4l2_subdev *sd = i2c_get_clientdata(client);
+        struct vc_device *device = to_vc_device(sd);
+
+        v4l2_async_unregister_subdev(&device->sd);
+        media_entity_cleanup(&device->sd.entity);
+        v4l2_ctrl_handler_free(&device->ctrl_handler);
+        pm_runtime_disable(&client->dev);
+	mutex_destroy(&device->mutex);
+
+        pm_runtime_get_sync(&client->dev);
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+	pm_runtime_put_noidle(&client->dev);
+
+        vc_set_power(device, 0);
+
+        return 0;
+}
+
+static const struct dev_pm_ops vc_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(vc_suspend, vc_resume)
+};
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id vc_acpi_ids[] = {
+	{"VCMIPICAM"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(acpi, vc_acpi_ids);
+#endif
+
+static const struct i2c_device_id vc_id[] = {
+        { "vc-mipi-cam", 0 },
+        { /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(i2c, vc_id);
+
+static const struct of_device_id vc_dt_ids[] = { 
+        { .compatible = "vc,vc_mipi" }, 
+        { /* sentinel */ } 
+};
+MODULE_DEVICE_TABLE(of, vc_dt_ids);
+
+static struct i2c_driver vc_i2c_driver = {
+        .driver = {
+                .name = "vc-mipi-cam",
+                .pm = &vc_pm_ops,
+		.acpi_match_table = ACPI_PTR(vc_acpi_ids),
+                .of_match_table = vc_dt_ids,
+        },
+        .id_table = vc_id,
+        .probe_new = vc_probe,
+        .remove   = vc_remove,
+};
+
+module_i2c_driver(vc_i2c_driver);
+
+MODULE_VERSION(VERSION);
+MODULE_DESCRIPTION("Vision Components GmbH - VC MIPI CSI-2 driver");
+MODULE_AUTHOR("Peter Martienssen, Liquify Consulting <peter.martienssen@liquify-consulting.de>");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/drivers/media/i2c/vc_mipi_core.c b/drivers/media/i2c/vc_mipi_core.c
new file mode 100755
index 000000000000..891f29481da4
--- /dev/null
+++ b/drivers/media/i2c/vc_mipi_core.c
@@ -0,0 +1,1637 @@
+#include "vc_mipi_core.h"
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/v4l2-mediabus.h>
+#include "vc_mipi_modules.h"
+
+// #define READ_VMAX
+
+#define MOD_REG_RESET            0x0100 // register  0 [0x0100]: reset and init register (R/W)
+#define MOD_REG_STATUS           0x0101 // register  1 [0x0101]: status (R)
+#define MOD_REG_MODE             0x0102 // register  2 [0x0102]: initialisation mode (R/W)
+#define MOD_REG_IOCTRL           0x0103 // register  3 [0x0103]: input/output control (R/W)
+#define MOD_REG_MOD_ADDR         0x0104 // register  4 [0x0104]: module i2c address (R/W, default: 0x10)
+#define MOD_REG_SEN_ADDR         0x0105 // register  5 [0x0105]: sensor i2c address (R/W, default: 0x1A)
+#define MOD_REG_OUTPUT           0x0106 // register  6 [0x0106]: output signal override register (R/W, default: 0x00)
+#define MOD_REG_INPUT            0x0107 // register  7 [0x0107]: input signal status register (R)
+#define MOD_REG_EXTTRIG          0x0108 // register  8 [0x0108]: external trigger enable (R/W, default: 0x00)
+#define MOD_REG_EXPO_L           0x0109 // register  9 [0x0109]: exposure LSB (R/W, default: 0x10)
+#define MOD_REG_EXPO_M           0x010A // register 10 [0x010A]: exposure 	   (R/W, default: 0x27)
+#define MOD_REG_EXPO_H           0x010B // register 11 [0x010B]: exposure     (R/W, default: 0x00)
+#define MOD_REG_EXPO_U           0x010C // register 12 [0x010C]: exposure MSB (R/W, default: 0x00)
+#define MOD_REG_RETRIG_L         0x010D // register 13 [0x010D]: retrigger LSB (R/W, default: 0x40)
+#define MOD_REG_RETRIG_M         0x010E // register 14 [0x010E]: retrigger     (R/W, default: 0x2D)
+#define MOD_REG_RETRIG_H         0x010F // register 15 [0x010F]: retrigger     (R/W, default: 0x29)
+#define MOD_REG_RETRIG_U         0x0110 // register 16 [0x0110]: retrigger MSB (R/W, default: 0x00)
+
+#define REG_RESET_PWR_UP         0x00
+#define REG_RESET_SENSOR         0x01   // reg0[0] = 0 sensor reset the sensor is held in reset when this bit is 1
+#define REG_RESET_PWR_DOWN       0x02   // reg0[1] = 0 power down power for the sensor is switched off
+#define REG_STATUS_NO_COM        0x00   // reg1[7:0] = 0x00 default, no communication with sensor possible
+#define REG_STATUS_READY         0x80   // reg1[7:0] = 0x80 sensor ready after successful initialization sequence
+#define REG_STATUS_ERROR         0x01   // reg1[7:0] = 0x01 internal error during initialization
+
+#define REG_IO_DISABLE     	 0x00
+#define REG_IO_FLASH_ENABLE      0x01
+#define REG_IO_FLASH_ACTIVE_LOW	 0x10
+#define REG_IO_TRIG_ACTIVE_LOW	 0x40
+
+#define REG_TRIGGER_DISABLE      0x00
+#define REG_TRIGGER_EXTERNAL     0x01
+#define REG_TRIGGER_PULSEWIDTH   0x02
+#define REG_TRIGGER_SELF         0x04
+#define REG_TRIGGER_SINGLE       0x08
+#define REG_TRIGGER_SYNC         0x10
+#define REG_TRIGGER_STREAM_EDGE  0x20
+#define REG_TRIGGER_STREAM_LEVEL 0x60
+
+#define MODE_TYPE_STREAM         0x01
+#define MODE_TYPE_TRIGGER        0x02
+#define MODE_TYPE_SLAVE          0x03
+
+// ------------------------------------------------------------------------------------------------
+// Function prototypes
+
+__u32 vc_core_calculate_max_exposure(struct vc_cam *cam, __u8 num_lanes, __u8 format);
+__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format);
+static __u32 vc_core_calculate_period_1H(struct vc_cam *cam, __u8 num_lanes, __u8 format);
+
+static int vc_sen_read_image_size(struct vc_ctrl *ctrl, struct vc_frame *size);
+#ifdef READ_VMAX
+static __u32 vc_sen_read_vmax(struct vc_ctrl *ctrl);
+#endif
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for I2C Communication
+
+#define U_BYTE(value) (__u8)((value >> 24) & 0xff)
+#define H_BYTE(value) (__u8)((value >> 16) & 0xff)
+#define M_BYTE(value) (__u8)((value >>  8) & 0xff)
+#define L_BYTE(value) (__u8)((value >>  0) & 0xff)
+
+static __u8 i2c_read_reg(struct device *dev, struct i2c_client *client, const __u16 addr, const char* func)
+{
+        __u8 buf[2] = { addr >> 8, addr & 0xff };
+        int ret;
+        struct i2c_msg msgs[] = {
+                {
+                        .addr = client->addr,
+                        .flags = 0,
+                        .len = 2,
+                        .buf = buf,
+                },
+                {
+                        .addr = client->addr,
+                        .flags = I2C_M_RD,
+                        .len = 1,
+                        .buf = buf,
+                },
+        };
+
+        ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+        if (ret < 0) {
+                vc_err(&client->dev, "%s():Â Reading register 0x%04x from 0x%02x failed\n", func, addr, client->addr);
+                return ret;
+        }
+
+        vc_dbg(dev, "%s():   addr: 0x%04x => value: 0x%02x\n", func, addr, buf[0]);
+
+        return buf[0];
+}
+
+static int i2c_write_reg(struct device *dev, struct i2c_client *client, const __u16 addr, const __u8 value, const char* func)
+{
+        struct i2c_adapter *adap = client->adapter;
+        struct i2c_msg msg;
+        __u8 tx[3];
+        int ret;
+
+        vc_dbg(dev, "%s():   addr: 0x%04x <= value: 0x%02x\n", func, addr, value);
+
+        msg.addr = client->addr;
+        msg.buf = tx;
+        msg.len = 3;
+        msg.flags = 0;
+        tx[0] = addr >> 8;
+        tx[1] = addr & 0xff;
+        tx[2] = value;
+        ret = i2c_transfer(adap, &msg, 1);
+
+        return ret == 1 ? 0 : -EIO;
+}
+
+static __u32 i2c_read_reg2(struct device *dev, struct i2c_client *client, struct vc_csr2 *csr, const char* func)
+{
+        __u32 reg = 0;
+        __u32 value = 0;
+
+        reg = i2c_read_reg(dev, client, csr->l, func);
+        if (reg)
+                value |= (0x000000ff & reg);
+        reg = i2c_read_reg(dev, client, csr->m, func);
+        if (reg)
+                value |= (0x000000ff & reg) <<  8;
+
+        return value;
+}
+
+static int i2c_write_reg2(struct device *dev, struct i2c_client *client, struct vc_csr2 *csr, const __u16 value, const char* func)
+{
+        int ret = 0;
+
+        if (csr->l)
+                ret  = i2c_write_reg(dev, client, csr->l, L_BYTE(value), func);
+        if (csr->m)
+                ret |= i2c_write_reg(dev, client, csr->m, M_BYTE(value), func);
+
+        return ret;
+}
+
+#ifdef READ_VMAX
+static __u32 i2c_read_reg4(struct device *dev, struct i2c_client *client, struct vc_csr4 *csr, const char* func)
+{
+        __u32 reg = 0;
+        __u32 value = 0;
+
+        reg = i2c_read_reg(dev, client, csr->l, func);
+        if (reg)
+                value |= (0x000000ff & reg);
+        reg = i2c_read_reg(dev, client, csr->m, func);
+        if (reg)
+                value |= (0x000000ff & reg) <<  8;
+        reg = i2c_read_reg(dev, client, csr->h, func);
+        if (reg)
+                value |= (0x000000ff & reg) << 16;
+        reg = i2c_read_reg(dev, client, csr->u, func);
+        if (reg)
+                value |= (0x000000ff & reg) << 24;
+
+        return value;
+}
+#endif
+
+static int i2c_write_reg4(struct device *dev, struct i2c_client *client, struct vc_csr4 *csr, const __u32 value, const char *func)
+{
+        int ret = 0;
+
+        if (csr->l)
+                ret = i2c_write_reg(dev, client, csr->l, L_BYTE(value), func);
+        if (csr->m)
+                ret |= i2c_write_reg(dev, client, csr->m, M_BYTE(value), func);
+        if (csr->h)
+                ret |= i2c_write_reg(dev, client, csr->h, H_BYTE(value), func);
+        if (csr->u)
+                ret |= i2c_write_reg(dev, client, csr->u, U_BYTE(value), func);
+
+        return ret;
+}
+
+int vc_read_i2c_reg(struct i2c_client *client, const __u16 addr)
+{
+        return i2c_read_reg(&client->dev, client, addr, __FUNCTION__);
+}
+
+int vc_write_i2c_reg(struct i2c_client *client, const __u16 addr, const __u8 value)
+{
+        return i2c_write_reg(&client->dev, client, addr, value, __FUNCTION__);
+}
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for debugging
+
+static void vc_core_print_desc(struct device *dev, struct vc_desc *desc)
+{
+        int is_color = vc_mod_is_color_sensor(desc);
+
+        vc_notice(dev, "+--- VC MIPI Camera -----------------------------------+\n");
+        vc_notice(dev, "| MANUF. | %s               MID: 0x%04x |\n", desc->manuf, desc->manuf_id);
+        vc_notice(dev, "| MODULE | ID:  0x%04x                     REV:   %04u |\n", desc->mod_id, desc->mod_rev);
+        vc_notice(dev, "| SENSOR | %s %s%s                                |\n", desc->sen_manuf, desc->sen_type, is_color ? "" : " ");
+        vc_notice(dev, "+--------+---------------------------------------------+\n");
+}
+
+static void vc_core_print_csr(struct device *dev, struct vc_desc *desc)
+{
+        vc_notice(dev, "+--- Sensor Registers ------+--------+--------+--------+\n");
+        vc_notice(dev, "|                           | low    | mid    | high   |\n");
+        vc_notice(dev, "+---------------------------+--------+--------+--------+\n");
+        vc_notice(dev, "| idle                      | 0x%04x |        |        |\n", desc->csr_mode);
+        vc_notice(dev, "| horizontal start          | 0x%04x | 0x%04x |        |\n", desc->csr_h_start_l, desc->csr_h_start_h);
+        vc_notice(dev, "| vertical start            | 0x%04x | 0x%04x |        |\n", desc->csr_v_start_l, desc->csr_v_start_h);
+        vc_notice(dev, "| horizontal end            | 0x%04x | 0x%04x |        |\n", desc->csr_h_end_l, desc->csr_h_end_h);
+        vc_notice(dev, "| vertical end              | 0x%04x | 0x%04x |        |\n", desc->csr_v_end_l, desc->csr_v_end_h);
+        vc_notice(dev, "| hor. output width         | 0x%04x | 0x%04x |        |\n", desc->csr_o_width_l, desc->csr_o_width_h);
+        vc_notice(dev, "| ver. output height        | 0x%04x | 0x%04x |        |\n", desc->csr_o_height_l, desc->csr_o_height_h);
+        vc_notice(dev, "| exposure                  | 0x%04x | 0x%04x | 0x%04x |\n", desc->csr_exposure_l, desc->csr_exposure_m, desc->csr_exposure_h);
+        vc_notice(dev, "| gain                      | 0x%04x | 0x%04x |        |\n", desc->csr_gain_l, desc->csr_gain_h);
+        vc_notice(dev, "+---------------------------+--------+--------+--------+\n");
+        vc_notice(dev, "| clock for ext. trigger    | %8u Hz              |\n", desc->clk_ext_trigger);
+        vc_notice(dev, "| pixel clock               | %8u Hz              |\n", desc->clk_pixel);
+        vc_notice(dev, "| shutter offset            | %8u us              |\n", desc->shutter_offset);
+        vc_notice(dev, "+---------------------------+--------------------------+\n");
+}
+
+static void vc_core_print_format(__u8 format, char *buf)
+{
+        switch (format) {
+        case FORMAT_RAW08: strcpy(buf, "RAW08"); break;
+        case FORMAT_RAW10: strcpy(buf, "RAW10"); break;
+        case FORMAT_RAW12: strcpy(buf, "RAW12"); break;
+        case FORMAT_RAW14: strcpy(buf, "RAW14"); break;
+        default: sprintf(buf, "0x%02x ", format); break;
+        }
+}
+
+static void vc_core_print_modes(struct device *dev, struct vc_desc *desc)
+{
+        struct vc_desc_mode *mode;
+        __u32 data_rate = 0;
+        char format[16], type[16];
+        int index = 0;
+
+        vc_notice(dev, "+--- Module Modes -------+---------+---------+---------+\n");
+        vc_notice(dev, "|  # | rate    | lanes   | format  | type    | binning |\n");
+        vc_notice(dev, "+----+---------+---------+---------+---------+---------+\n");
+        for (index = 0; index<desc->num_modes; index++) {
+                mode = &desc->modes[index];
+                data_rate = (*(__u32*)mode->data_rate)/1000000;
+                vc_core_print_format(mode->format, format);
+                switch (mode->type) {
+                case MODE_TYPE_STREAM:  strcpy(type, "STREAM "); break;
+                case MODE_TYPE_TRIGGER: strcpy(type, "EXT.TRG"); break;
+                case MODE_TYPE_SLAVE:   strcpy(type, "SLAVE  "); break;
+                default: sprintf(type, "0x%02x   ", mode->type); break;
+                }
+                vc_notice(dev, "| %2d |    %4u |       %u | %s   | %s |       %u |\n",
+                        index, data_rate, mode->num_lanes, format, type, mode->binning);
+        }
+        vc_notice(dev, "+----+---------+---------+---------+---------+---------+\n");
+}
+
+static void vc_core_print_timing(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct device *dev = vc_core_get_mod_device(cam);
+        char sformat[16];
+        int index = 0;
+
+        if (ctrl->flags & FLAG_INCREASE_FRAME_RATE) {
+                vc_notice(dev, "+-------+--------+----------+-----------+\n");
+                vc_notice(dev, "| lanes | format | exposure | framerate |\n");
+                vc_notice(dev, "|       |        | max [us] | max [mHz] |\n");
+                vc_notice(dev, "+-------+--------+----------+-----------+\n");
+                while (index < 8 && ctrl->expo_timing[index].num_lanes != 0) {
+                        __u8 num_lanes = ctrl->expo_timing[index].num_lanes;
+                        __u8 format = ctrl->expo_timing[index].format;
+                        __u32 max_exposure = vc_core_calculate_max_exposure(cam, num_lanes, format);
+                        __u32 max_frame_rate = vc_core_calculate_max_frame_rate(cam, num_lanes, format);
+
+                        vc_core_print_format(format, sformat);
+                        vc_notice(dev, "|     %1d | %s  | %8d | %9d |\n",
+                                num_lanes, sformat, max_exposure, max_frame_rate);
+                        index++;
+                }
+                vc_notice(dev, "+-------+--------+----------+-----------+\n");
+        }
+}
+
+void vc_core_print_debug(struct vc_cam *cam)
+{
+        vc_core_print_timing(cam);
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Helper functions for internal data structures
+
+struct device *vc_core_get_sen_device(struct vc_cam *cam)
+{
+        return &cam->ctrl.client_sen->dev;
+}
+
+struct device *vc_core_get_mod_device(struct vc_cam *cam)
+{
+        return &cam->ctrl.client_mod->dev;
+}
+
+static int vc_core_get_v4l2_fmt(__u32 code, char *buf)
+{
+        switch(code) {
+        case MEDIA_BUS_FMT_Y8_1X8:       sprintf(buf, "GREY"); break;
+        case MEDIA_BUS_FMT_Y10_1X10:     sprintf(buf, "Y10 "); break;
+        case MEDIA_BUS_FMT_Y12_1X12:     sprintf(buf, "Y12 "); break;
+        case MEDIA_BUS_FMT_Y14_1X14:     sprintf(buf, "Y14 "); break;
+        case MEDIA_BUS_FMT_SRGGB8_1X8:   sprintf(buf, "RGGB"); break;
+        case MEDIA_BUS_FMT_SRGGB10_1X10: sprintf(buf, "RG10"); break;
+        case MEDIA_BUS_FMT_SRGGB12_1X12: sprintf(buf, "RG12"); break;
+        case MEDIA_BUS_FMT_SRGGB14_1X14: sprintf(buf, "RG14"); break;
+        case MEDIA_BUS_FMT_SGBRG8_1X8:   sprintf(buf, "GBRG"); break;
+        case MEDIA_BUS_FMT_SGBRG10_1X10: sprintf(buf, "GB10"); break;
+        case MEDIA_BUS_FMT_SGBRG12_1X12: sprintf(buf, "GB12"); break;
+        case MEDIA_BUS_FMT_SGBRG14_1X14: sprintf(buf, "GB14"); break;
+        default: return -EINVAL;
+        }
+        return 0;
+}
+
+static __u8 vc_core_v4l2_code_to_format(__u32 code)
+{
+        switch (code) {
+        case MEDIA_BUS_FMT_Y8_1X8:
+        case MEDIA_BUS_FMT_SRGGB8_1X8:
+        case MEDIA_BUS_FMT_SGBRG8_1X8:
+                return FORMAT_RAW08;
+        case MEDIA_BUS_FMT_Y10_1X10:
+        case MEDIA_BUS_FMT_SRGGB10_1X10:
+        case MEDIA_BUS_FMT_SGBRG10_1X10:
+                return FORMAT_RAW10;
+        case MEDIA_BUS_FMT_Y12_1X12:
+        case MEDIA_BUS_FMT_SRGGB12_1X12:
+        case MEDIA_BUS_FMT_SGBRG12_1X12:
+                return FORMAT_RAW12;
+        case MEDIA_BUS_FMT_Y14_1X14:
+        case MEDIA_BUS_FMT_SRGGB14_1X14:
+        case MEDIA_BUS_FMT_SGBRG14_1X14:
+                return FORMAT_RAW14;
+        }
+        return 0;
+}
+
+static __u32 vc_core_format_to_v4l2_code(__u8 format, int is_color, int is_gbrg)
+{
+        switch (format) {
+        case FORMAT_RAW08:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG8_1X8 : MEDIA_BUS_FMT_SRGGB8_1X8) : MEDIA_BUS_FMT_Y8_1X8;
+        case FORMAT_RAW10:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG10_1X10 : MEDIA_BUS_FMT_SRGGB10_1X10) : MEDIA_BUS_FMT_Y10_1X10;
+        case FORMAT_RAW12:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG12_1X12 : MEDIA_BUS_FMT_SRGGB12_1X12) : MEDIA_BUS_FMT_Y12_1X12;
+        case FORMAT_RAW14:
+                return is_color ? (is_gbrg ? MEDIA_BUS_FMT_SGBRG14_1X14 : MEDIA_BUS_FMT_SRGGB14_1X14) : MEDIA_BUS_FMT_Y14_1X14;
+        }
+        return 0;
+}
+
+static __u32 vc_core_get_default_format(struct vc_cam *cam)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        __u8 format = desc->modes[0].format;
+        int is_color = vc_mod_is_color_sensor(desc);
+        int is_bgrg = ctrl->flags & FLAG_FORMAT_GBRG;
+        return vc_core_format_to_v4l2_code(format, is_color, is_bgrg);
+}
+
+int vc_core_try_format(struct vc_cam *cam, __u32 code)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u8 format = vc_core_v4l2_code_to_format(code);
+        char fourcc[5];
+        int index;
+
+        vc_core_get_v4l2_fmt(code, fourcc);
+        vc_info(dev, "%s(): Try format 0x%04x (%s, format: 0x%02x)\n", __FUNCTION__, code, fourcc, format);
+
+        for (index = 0; index < desc->num_modes; index++) {
+                struct vc_desc_mode *mode = &desc->modes[index];
+                vc_dbg(dev, "%s(): Checking mode %u (format: 0x%02x)", __FUNCTION__, index, mode->format);
+                if(mode->format == format) {
+                        return 0;
+                }
+        }
+
+        return -EINVAL;
+}
+
+int vc_core_set_format(struct vc_cam *cam, __u32 code)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        char fourcc[5];
+
+        vc_core_get_v4l2_fmt(code, fourcc);
+        vc_notice(dev, "%s(): Set format 0x%04x (%s)\n", __FUNCTION__, code, fourcc);
+
+        if (vc_core_try_format(cam, code)) {
+                state->format_code = vc_core_get_default_format(cam);
+                vc_core_update_controls(cam);
+                vc_err(dev, "%s(): Format 0x%04x not supported! (Set default format: 0x%04x)\n", __FUNCTION__, code, state->format_code);
+                 return -EINVAL;
+        }
+
+        state->format_code = code;
+        vc_core_update_controls(cam);
+
+        return 0;
+}
+
+__u32 vc_core_get_format(struct vc_cam *cam)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u32 code = state->format_code;
+        char fourcc[5];
+
+        vc_core_get_v4l2_fmt(code, fourcc);
+        vc_info(dev, "%s(): Get format 0x%04x (%s)\n", __FUNCTION__, code, fourcc);
+
+        return code;
+}
+
+int vc_core_set_frame(struct vc_cam *cam, __u32 left, __u32 top, __u32 width, __u32 height)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_notice(dev, "%s(): Set frame (left: %u, top: %u, width: %u, height: %u)\n", __FUNCTION__, left, top, width, height);
+
+        if (width > ctrl->frame.width) {
+                state->frame.width = ctrl->frame.width;
+        } else {
+                state->frame.width = width;
+        }
+
+        if (left > ctrl->frame.width - state->frame.width) {
+                state->frame.left = ctrl->frame.width - state->frame.width;
+        } else {
+                state->frame.left = left;
+        }
+
+        if (height > ctrl->frame.height) {
+                state->frame.height = ctrl->frame.height;
+        } else {
+                state->frame.height = height;
+        }
+
+        if (top > ctrl->frame.height - state->frame.height) {
+                state->frame.top = ctrl->frame.height - state->frame.height;
+        } else {
+                state->frame.top = top;
+        }
+
+        if (state->frame.left != left || state->frame.top != top || state->frame.width != width || state->frame.height != height) {
+                vc_warn(dev, "%s(): Adjusted frame (left: %u, top: %u, width: %u, height: %u)\n", __FUNCTION__,
+                state->frame.left, state->frame.top, state->frame.width, state->frame.height);
+        }
+
+        return 0;
+}
+
+struct vc_frame *vc_core_get_frame(struct vc_cam *cam)
+{
+        struct vc_frame* frame = &cam->state.frame;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_info(dev, "%s(): Get frame (width: %u, height: %u)\n", __FUNCTION__, frame->width, frame->height);
+
+        return frame;
+}
+
+int vc_core_set_num_lanes(struct vc_cam *cam, __u32 number)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u8 index = 0;
+
+        for (index = 0; index < desc->num_modes; index++) {
+                struct vc_desc_mode *mode = &desc->modes[index];
+                if (mode->num_lanes == number) {
+                        vc_info(dev, "%s(): Set number of lanes %u\n", __FUNCTION__, number);
+                        state->num_lanes = number;
+                        vc_core_update_controls(cam);
+                        return 0;
+                }
+        }
+
+        vc_err(dev, "%s(): Number of lanes %u not supported!\n", __FUNCTION__, number);
+        return -EINVAL;
+}
+
+__u32 vc_core_get_num_lanes(struct vc_cam *cam)
+{
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_info(dev, "%s(): Get number of lanes: %u\n", __FUNCTION__, state->num_lanes);
+        return state->num_lanes;
+}
+
+int vc_core_set_framerate(struct vc_cam *cam, __u32 framerate)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        vc_notice(dev, "%s(): Set framerate %u mHz\n", __FUNCTION__, framerate);
+
+        if (framerate < ctrl->framerate.min) {
+                framerate = ctrl->framerate.min;
+        }
+        if (framerate > ctrl->framerate.max) {
+                framerate = ctrl->framerate.max;
+        }
+        state->framerate = framerate;
+
+        return vc_sen_set_exposure(cam, cam->state.exposure);
+}
+
+__u32 vc_core_get_framerate(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u32 framerate = 0;
+
+        if (state->framerate > 0) {
+                framerate = state->framerate;
+        } else {
+                framerate = ctrl->framerate.max;
+        }
+
+        vc_info(dev, "%s(): Get framerate %u mHz\n", __FUNCTION__, framerate);
+        return framerate;
+}
+
+__u32 vc_core_calculate_max_exposure(struct vc_cam *cam, __u8 num_lanes, __u8 format)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct device *dev = vc_core_get_sen_device(cam);
+
+        switch (cam->state.trigger_mode) {
+        case REG_TRIGGER_DISABLE:
+        case REG_TRIGGER_SYNC:
+        case REG_TRIGGER_STREAM_EDGE:
+        case REG_TRIGGER_STREAM_LEVEL:
+        default:
+                {
+                        __u32 period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format);
+                        vc_dbg(dev, "%s(): period_1H_ns: %u, vmax.max: %u, vmax.min: %u\n",
+                                __FUNCTION__, period_1H_ns, ctrl->vmax.max, ctrl->vmax.min);
+                        return ((__u64)period_1H_ns * (cam->ctrl.vmax.max - ctrl->vmax.min)) / 1000;
+                }
+        case REG_TRIGGER_EXTERNAL:
+        case REG_TRIGGER_PULSEWIDTH:
+        case REG_TRIGGER_SELF:
+        case REG_TRIGGER_SINGLE:
+                {
+                        vc_dbg(dev, "%s(): clk_ext_trigger: %u\n", __FUNCTION__, ctrl->clk_ext_trigger);
+                        return ((__u64)0xffffffff * 1000000) / ctrl->clk_ext_trigger;
+                }
+        }
+}
+
+__u32 vc_core_get_optimized_vmax(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+
+        // Increase the frame rate when image height is reduced.
+        if (ctrl->flags & FLAG_INCREASE_FRAME_RATE && state->frame.height < ctrl->frame.height) {
+                return ctrl->vmax.def - (ctrl->frame.height - state->frame.height);
+
+                vc_notice(dev, "%s(): Increased frame rate: vmax %u/%u, height: %u/%u\n", __FUNCTION__,
+                        state->vmax, ctrl->vmax.def, state->frame.height, ctrl->frame.height);
+        }
+
+        return ctrl->vmax.def;
+}
+
+__u32 vc_core_calculate_max_frame_rate(struct vc_cam *cam, __u8 num_lanes, __u8 format)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u32 period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format);
+        __u32 vmax = vc_core_get_optimized_vmax(cam);
+
+        vc_dbg(dev, "%s(): period_1H_ns: %u, vmax: %u/%u\n",
+                __FUNCTION__, period_1H_ns, vmax, ctrl->vmax.def);
+
+        return 1000000000 / (((__u64)period_1H_ns * vmax) / 1000);
+}
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for the VC MIPI Controller Module
+
+static struct i2c_client *vc_mod_get_client(struct device *dev, struct i2c_adapter *adapter, __u8 i2c_addr)
+{
+        struct i2c_client *client;
+        struct i2c_board_info info = {
+                I2C_BOARD_INFO("i2c", i2c_addr),
+        };
+        unsigned short addr_list[2] = { i2c_addr, I2C_CLIENT_END };
+        int count;
+
+        for (count = 0; count < 200; count++) {
+                msleep(1);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,5,0)
+                client = i2c_new_probed_device(adapter, &info, addr_list, NULL);
+                if (client != NULL) {
+                        vc_dbg(dev, "%s(): %u attempts took %u ms to probe i2c device 0x%02x\n", __func__, count, count, i2c_addr);
+                        return client;
+                }
+#else
+                client = i2c_new_scanned_device(adapter, &info, addr_list, NULL);
+                if (!IS_ERR(client)) {
+                        vc_dbg(dev, "%s(): %u attempts took %u ms to scan i2c device 0x%02x\n", __func__, count, count, i2c_addr);
+                        return client;
+                }
+#endif
+        }
+
+        // How to change the drivers name.
+        // i2c 6-0010
+        //  ^     ^
+        //  |     +--- The device name is set by
+        //  |          i2c_new_probed_device() -> i2c_new_device() -> i2c_dev_set_name()
+        //  |          dev_set_name() and dev_name()
+        //  +---------
+        // dev = &client->dev;
+        // vc_info(dev, "%s(): dev_name:%s\n", __FUNCTION__, dev_name(dev));
+        // if (dev->driver == 0) {
+        // 	vc_err(dev, "%s(): dev->driver == 0\n", __FUNCTION__);
+        // }
+
+        return NULL;
+}
+
+int vc_mod_set_power(struct vc_cam *cam, int on)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client_mod = ctrl->client_mod;
+        struct device *dev = &client_mod->dev;
+        int ret;
+
+        vc_info(dev, "%s(): Set module power: %s\n", __FUNCTION__, on ? "up" : "down");
+
+        ret = i2c_write_reg(dev, client_mod, MOD_REG_RESET, on ? REG_RESET_PWR_UP : REG_RESET_PWR_DOWN, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Unable to power %s the module (error: %d)\n", __FUNCTION__,
+                        (on == REG_RESET_PWR_UP) ? "up" : "down", ret);
+                cam->state.power_on = 0;
+                return ret;
+        }
+
+        cam->state.power_on = on;
+        return 0;
+}
+
+static int vc_mod_read_status(struct i2c_client *client)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        ret = i2c_read_reg(dev, client, MOD_REG_STATUS, __FUNCTION__);
+        if (ret < 0)
+                vc_err(dev, "%s(): Unable to get module status (error: %d)\n", __FUNCTION__, ret);
+        else
+                vc_dbg(dev, "%s(): Get module status: 0x%02x\n", __FUNCTION__, ret);
+
+        return ret;
+}
+
+static int vc_mod_write_trigger_mode(struct i2c_client *client, int mode)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write trigger mode: 0x%02x\n", __FUNCTION__, mode);
+
+        ret = i2c_write_reg(dev, client, MOD_REG_EXTTRIG, mode, __FUNCTION__);
+        if (ret)
+                vc_err(dev, "%s(): Unable to write external trigger (error: %d)\n", __FUNCTION__, ret);
+
+        return ret;
+}
+
+static int vc_mod_write_io_mode(struct i2c_client *client, int mode)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write IO mode: %s\n", __FUNCTION__, mode ? "ON" : "OFF");
+
+        ret = i2c_write_reg(dev, client, MOD_REG_IOCTRL, mode, __FUNCTION__);
+        if (ret)
+                vc_err(dev, "%s(): Unable to write IO mode (error: %d)\n", __FUNCTION__, ret);
+
+        return ret;
+}
+
+static int vc_mod_wait_until_module_is_ready(struct i2c_client *client)
+{
+        struct device *dev = &client->dev;
+        int status;
+        int try;
+
+        vc_dbg(dev, "%s(): Wait until module is ready\n", __FUNCTION__);
+
+        status = REG_STATUS_NO_COM;
+        try = 0;
+        while (status == REG_STATUS_NO_COM && try < 10) {
+                usleep_range(200000, 200000);
+                status = vc_mod_read_status(client);
+                try++;
+        }
+        if (status == REG_STATUS_ERROR) {
+                vc_err(dev, "%s(): Internal Error!", __func__);
+                return -EIO;
+        }
+
+        vc_dbg(dev, "%s(): Module is ready!\n", __FUNCTION__);
+        return 0;
+}
+
+static int vc_mod_setup(struct vc_ctrl *ctrl, int mod_i2c_addr, struct vc_desc *desc)
+{
+        struct i2c_client *client_sen = ctrl->client_sen;
+        struct i2c_adapter *adapter = client_sen->adapter;
+        struct device *dev_sen = &client_sen->dev;
+        struct i2c_client *client_mod;
+        struct device *dev_mod;
+        int addr, reg;
+
+        vc_dbg(dev_sen, "%s(): Setup the module\n", __FUNCTION__);
+
+        if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+                vc_err(dev_sen, "%s(): I2C-Adapter doesn't support I2C_FUNC_SMBUS_BYTE\n", __FUNCTION__);
+                return 0;
+        }
+
+        client_mod = vc_mod_get_client(dev_sen, adapter, mod_i2c_addr);
+        if (client_mod == 0) {
+                vc_err(dev_sen, "%s(): Unable to get module I2C client for address 0x%02x\n", __FUNCTION__, mod_i2c_addr);
+                return -EIO;
+        }
+
+        dev_mod = &client_mod->dev;
+        for (addr = 0; addr < sizeof(*desc); addr++) {
+                reg = i2c_read_reg(dev_mod, client_mod, addr + 0x1000, __FUNCTION__);
+                if (reg < 0) {
+                        i2c_unregister_device(client_mod);
+                        return -EIO;
+                }
+                *((char *)(desc) + addr) = (char)reg;
+        }
+
+        // TODO: Check if connected module is really a VC MIPI module
+        vc_core_print_desc(dev_mod, desc);
+        vc_core_print_csr(dev_mod, desc);
+        vc_core_print_modes(dev_mod, desc);
+
+        ctrl->client_mod = client_mod;
+        ctrl->mod_i2c_addr = mod_i2c_addr;
+
+        if (desc->num_modes == 0) {
+                vc_err(dev_mod, "%s(): Could not find any module modes! Operation not possible!\n", __FUNCTION__);
+                return -EIO;
+        }
+
+        return 0;
+}
+
+int vc_core_update_controls(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_v4l2_code_to_format(state->format_code);
+
+        if (ctrl->flags & FLAG_INCREASE_FRAME_RATE) {
+                ctrl->exposure.max = vc_core_calculate_max_exposure(cam, num_lanes, format);
+                ctrl->framerate.max = vc_core_calculate_max_frame_rate(cam, num_lanes, format);
+
+                vc_dbg(dev, "%s(): num_lanes: %u, format %u, exposure.max: %u us, framerate.max: %u mHz\n",
+                        __FUNCTION__, num_lanes, format, ctrl->exposure.max, ctrl->framerate.max);
+        }
+
+        return 0;
+}
+
+static void vc_core_state_init(struct vc_cam *cam)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+
+        state->mode = 0xff;
+        state->exposure = ctrl->exposure.def;
+        state->gain = ctrl->gain.def;
+        state->blacklevel = ctrl->blacklevel.def;
+        state->shs = 0;
+        state->vmax = 0;
+        state->exposure_cnt = 0;
+        state->retrigger_cnt = 0;
+        state->framerate = ctrl->framerate.def;
+        state->num_lanes = desc->modes[0].num_lanes;
+        state->format_code = vc_core_get_default_format(cam);
+        state->frame.left = 0;
+        state->frame.top = 0;
+        state->frame.width = ctrl->frame.width;
+        state->frame.height = ctrl->frame.height;
+        state->streaming = 0;
+        state->flags = 0x00;
+}
+
+int vc_core_init(struct vc_cam *cam, struct i2c_client *client)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        int ret;
+
+        ctrl->client_sen = client;
+        ret = vc_mod_setup(ctrl, 0x10, desc);
+        if (ret) {
+                return -EIO;
+        }
+        ret = vc_mod_ctrl_init(ctrl, desc);
+        if (ret) {
+                return -EIO;
+        }
+        if (ctrl->frame.width == 0 || ctrl->frame.height == 0) {
+                vc_sen_read_image_size(ctrl, &ctrl->frame);
+        }
+#ifdef READ_VMAX
+        vc_sen_read_vmax(&cam->ctrl);
+#endif
+        vc_core_state_init(cam);
+        vc_core_update_controls(cam);
+        vc_core_print_timing(cam);
+
+        vc_notice(&ctrl->client_mod->dev, "VC MIPI Core successfully initialized");
+        return 0;
+}
+
+static int vc_mod_write_exposure(struct i2c_client *client, __u32 value)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write module exposure = 0x%08x (%u)\n", __FUNCTION__, value, value);
+
+        ret  = i2c_write_reg(dev, client, MOD_REG_EXPO_L, L_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_EXPO_M, M_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_EXPO_H, H_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_EXPO_U, U_BYTE(value), __FUNCTION__);
+
+        return ret;
+}
+
+static int vc_mod_write_retrigger(struct i2c_client *client, __u32 value)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write module retrigger = 0x%08x (%u)\n", __FUNCTION__, value, value);
+
+        ret  = i2c_write_reg(dev, client, MOD_REG_RETRIG_L, L_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_RETRIG_M, M_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_RETRIG_H, H_BYTE(value), __FUNCTION__);
+        ret |= i2c_write_reg(dev, client, MOD_REG_RETRIG_U, U_BYTE(value), __FUNCTION__);
+
+        return ret;
+}
+
+static __u8 vc_mod_find_mode(struct vc_cam *cam, __u8 num_lanes, __u8 format, __u8 type, __u8 binning)
+{
+        struct vc_desc *desc = &cam->desc;
+        struct device *dev = vc_core_get_mod_device(cam);
+        __u8 index = 0;
+
+        for (index = 0; index < desc->num_modes; index++) {
+                struct vc_desc_mode *mode = &desc->modes[index];
+                vc_dbg(dev, "%s(): Checking mode (#%02u, lanes: %u, format: 0x%02x, type: 0x%02x, binning: 0x%02x)", __FUNCTION__,
+                        index, mode->num_lanes, mode->format, mode->type, mode->binning);
+                if(mode->num_lanes == num_lanes && mode->format == format && mode->type == type && mode->binning == binning) {
+                        return index;
+                }
+        }
+        return 0;
+}
+
+static int vc_mod_write_mode(struct i2c_client *client, __u8 mode)
+{
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Write module mode: 0x%02x\n", __FUNCTION__, mode);
+
+        ret = i2c_write_reg(dev, client, MOD_REG_MODE, mode, __FUNCTION__);
+        if (ret)
+                vc_err(dev, "%s(): Unable to write module mode: 0x%02x (error: %d)\n", __FUNCTION__, mode, ret);
+
+        return ret;
+}
+
+static int vc_mod_reset_module(struct vc_cam *cam, __u8 mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client = ctrl->client_mod;
+        struct device *dev = &client->dev;
+        int ret;
+
+        vc_dbg(dev, "%s(): Reset the module!\n", __FUNCTION__);
+
+        ret = vc_mod_set_power(cam, 0);
+        ret |= vc_mod_write_mode(client, mode);
+        ret |= vc_mod_set_power(cam, 1);
+        ret |= vc_mod_wait_until_module_is_ready(client);
+
+        return ret;
+}
+
+int vc_mod_set_mode(struct vc_cam *cam, int *reset)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_mod_device(cam);
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_v4l2_code_to_format(state->format_code);
+        char fourcc[5];
+        char *stype;
+        __u8 type = 0;
+        __u8 binning = 0; // TODO: Not implemented yet
+        __u8 mode = 0;
+        int ret = 0;
+
+        switch (cam->state.trigger_mode) {
+        case REG_TRIGGER_DISABLE:
+        case REG_TRIGGER_SYNC:
+        case REG_TRIGGER_STREAM_EDGE:
+        case REG_TRIGGER_STREAM_LEVEL:
+        default:
+                type = MODE_TYPE_STREAM;
+                stype = "STREAM";
+                break;
+        case REG_TRIGGER_EXTERNAL:
+        case REG_TRIGGER_PULSEWIDTH:
+        case REG_TRIGGER_SELF:
+        case REG_TRIGGER_SINGLE:
+                type = MODE_TYPE_TRIGGER;
+                stype = "EXT.TRG";
+                break;
+        }
+
+        mode = vc_mod_find_mode(cam, num_lanes, format, type, binning);
+        if (mode == state->mode && !(ctrl->flags & FLAG_RESET_ALWAYS)) {
+                vc_dbg(dev, "%s(): Module mode %u already set!\n", __FUNCTION__, mode);
+                *reset = 0;
+                return 0;
+        }
+
+        vc_core_get_v4l2_fmt(state->format_code, fourcc);
+        vc_notice(dev, "%s(): Set module mode: %u (lanes: %u, format: %s, type: %s)\n", __FUNCTION__,
+                mode, num_lanes, fourcc, stype);
+
+        ret = vc_mod_reset_module(cam, mode);
+        if (ret) {
+                vc_err(dev, "%s(): Unable to set module mode: %u (lanes: %u, format: %s, type: %s) (error: %d)\n", __func__,
+                        mode, num_lanes, fourcc, stype, ret);
+                return ret;
+        }
+
+        state->mode = mode;
+        *reset = 1;
+
+        return ret;
+}
+
+int vc_mod_is_trigger_enabled(struct vc_cam *cam)
+{
+        return cam->state.trigger_mode != REG_TRIGGER_DISABLE;
+}
+
+int vc_mod_set_trigger_mode(struct vc_cam *cam, int mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_mod_device(cam);
+        char *mode_desc;
+
+        if (mode == 0) {
+                mode_desc = "DISABLED";
+                state->trigger_mode = REG_TRIGGER_DISABLE;
+
+        } else if (mode == 1 && ctrl->flags & FLAG_TRIGGER_EXTERNAL) {
+                mode_desc = "EXTERNAL";
+                state->trigger_mode = REG_TRIGGER_EXTERNAL;
+
+        } else if (mode == 2 && ctrl->flags & FLAG_TRIGGER_PULSEWIDTH) {
+                mode_desc = "PULSEWIDTH";
+                state->trigger_mode = REG_TRIGGER_PULSEWIDTH;
+
+        } else if (mode == 3 && ctrl->flags & (FLAG_TRIGGER_SELF | FLAG_TRIGGER_SELF_V2)) {
+                mode_desc = "SELF";
+                state->trigger_mode = REG_TRIGGER_SELF;
+
+        } else if (mode == 4 && ctrl->flags & FLAG_TRIGGER_SINGLE) {
+                mode_desc = "SINGLE";
+                state->trigger_mode = REG_TRIGGER_SINGLE;
+
+        } else if (mode == 5 && ctrl->flags & FLAG_TRIGGER_SYNC) {
+                mode_desc = "SYNC";
+                state->trigger_mode = REG_TRIGGER_SYNC;
+
+        } else if (mode == 6 && ctrl->flags & FLAG_TRIGGER_STREAM_EDGE) {
+                mode_desc = "STREAM_EDGE";
+                state->trigger_mode = REG_TRIGGER_STREAM_EDGE;
+
+        } else if (mode == 7 && ctrl->flags & FLAG_TRIGGER_STREAM_LEVEL) {
+                mode_desc = "STREAM_LEVEL";
+                state->trigger_mode = REG_TRIGGER_STREAM_LEVEL;
+
+        } else {
+                vc_err(dev, "%s(): Trigger mode %d not supported!\n", __FUNCTION__, mode);
+                return -EINVAL;
+        }
+
+        vc_core_update_controls(cam);
+
+        vc_notice(dev, "%s(): Set trigger mode: %s\n", __FUNCTION__, mode_desc);
+
+        return 0;
+}
+
+int vc_mod_get_trigger_mode(struct vc_cam *cam)
+{
+        switch (cam->state.trigger_mode)  {
+        case REG_TRIGGER_DISABLE: 	return 0;
+        case REG_TRIGGER_EXTERNAL: 	return 1;
+        case REG_TRIGGER_PULSEWIDTH: 	return 2;
+        case REG_TRIGGER_SELF:		return 3;
+        case REG_TRIGGER_SINGLE:	return 4;
+        case REG_TRIGGER_SYNC:		return 5;
+        case REG_TRIGGER_STREAM_EDGE:	return 6;
+        case REG_TRIGGER_STREAM_LEVEL:	return 7;
+        }
+        return 0;
+}
+
+int vc_mod_set_single_trigger(struct vc_cam *cam)
+{
+        struct i2c_client *client = cam->ctrl.client_mod;
+        struct device *dev = &client->dev;
+
+        vc_notice(dev, "%s(): Set single trigger\n", __FUNCTION__);
+
+        return i2c_write_reg(dev, client, MOD_REG_EXTTRIG, REG_TRIGGER_SINGLE, __FUNCTION__);
+}
+
+int vc_mod_is_io_enabled(struct vc_cam *cam)
+{
+        return cam->state.io_mode != REG_IO_DISABLE;
+}
+
+int vc_mod_set_io_mode(struct vc_cam *cam, int mode)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_mod_device(cam);
+        char *mode_desc = NULL;
+
+        if (mode == 0) {
+                mode_desc = "DISABLED";
+                state->io_mode = REG_IO_DISABLE;
+
+        } else if (ctrl->flags & FLAG_IO_ENABLED) {
+                switch (mode) {
+                case 1:
+                        mode_desc = "FLASH ACTIVE HIGH";
+                state->io_mode = REG_IO_FLASH_ENABLE;
+                        break;
+                case 2:
+                        mode_desc = "FLASH ACTIVE LOW";
+                        state->io_mode = REG_IO_FLASH_ENABLE | REG_IO_FLASH_ACTIVE_LOW;
+                        break;
+                case 3:
+                        mode_desc = "TRIGGER ACTIVE LOW";
+                        state->io_mode = REG_IO_TRIG_ACTIVE_LOW;
+                        break;
+                case 4:
+                        mode_desc = "TRIGGER ACTIVE LOW / FLASH ACTIVE HIGH";
+                        state->io_mode = REG_IO_FLASH_ENABLE | REG_IO_TRIG_ACTIVE_LOW;
+                        break;
+                case 5:
+                        mode_desc = "TRIGGER AND FLASH ACTIVE LOW";
+                        state->io_mode = REG_IO_FLASH_ENABLE | REG_IO_FLASH_ACTIVE_LOW | REG_IO_TRIG_ACTIVE_LOW;
+                        break;
+                }
+        }
+
+        if (mode_desc == NULL) {
+                vc_err(dev, "%s(): IO mode %d not supported!\n", __FUNCTION__, mode);
+                return -EINVAL;
+        }
+
+        vc_notice(dev, "%s(): Set IO mode: %s\n", __FUNCTION__, mode_desc);
+
+        return 0;
+}
+
+int vc_mod_get_io_mode(struct vc_cam *cam)
+{
+        switch (cam->state.io_mode)  {
+        case REG_IO_DISABLE: 		return 0;
+        case REG_IO_FLASH_ENABLE: 	return 1;
+        }
+        return 0;
+}
+
+
+// ------------------------------------------------------------------------------------------------
+//  Helper Functions for the VC MIPI Sensors
+
+static int vc_sen_write_mode(struct vc_ctrl *ctrl, int mode)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        __u8 value;
+        int ret = 0;
+
+        vc_dbg(dev, "%s(): Write sensor mode: %s\n", __FUNCTION__, (mode == ctrl->csr.sen.mode_standby)? "standby" : "operating");
+
+        // TODO: Check if it is realy nessesary to swap order of write opertations.
+        if(mode == ctrl->csr.sen.mode_standby) {
+                value = ctrl->csr.sen.mode_standby;
+                if(ctrl->csr.sen.mode.l) {
+                        ret = i2c_write_reg(dev, client, ctrl->csr.sen.mode.l, value, __FUNCTION__);
+                }
+                if(ctrl->csr.sen.mode.m) {
+                        ret |= i2c_write_reg(dev, client, ctrl->csr.sen.mode.m, value, __FUNCTION__);
+                }
+        } else {
+                value = ctrl->csr.sen.mode_operating;
+                if(ctrl->csr.sen.mode.m) {
+                        ret |= i2c_write_reg(dev, client, ctrl->csr.sen.mode.m, value, __FUNCTION__);
+                }
+                if(ctrl->csr.sen.mode.l) {
+                        ret = i2c_write_reg(dev, client, ctrl->csr.sen.mode.l, value, __FUNCTION__);
+                }
+        }
+        if (ret)
+                vc_err(dev, "%s(): Couldn't write sensor mode: 0x%02x (error: %d)\n", __FUNCTION__, mode, ret);
+
+        return ret;
+}
+
+static int vc_sen_read_image_size(struct vc_ctrl *ctrl, struct vc_frame *size)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        size->width = i2c_read_reg2(dev, client, &ctrl->csr.sen.o_width, __FUNCTION__);
+        size->height = i2c_read_reg2(dev, client, &ctrl->csr.sen.o_height, __FUNCTION__);
+
+        vc_dbg(dev, "%s(): Read image size (width: %u, height: %u)\n", __FUNCTION__, size->width, size->height);
+
+        return 0;
+}
+
+int vc_sen_set_roi(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        int w_left, w_top, w_width, w_height;
+        int ret = 0;
+
+        w_left = ctrl->frame.left + state->frame.left;
+        w_top = ctrl->frame.top + state->frame.top;
+        w_width = state->frame.width;
+        w_height = state->frame.height;
+
+        if (ctrl->flags & FLAG_DOUBLE_HEIGHT) {
+                w_top *= 2;
+                w_height *= 2;
+        }
+
+        vc_notice(dev, "%s(): Set sensor roi: (left: %u, top: %u, width: %u, height: %u)\n", __FUNCTION__,
+                w_left, w_top, w_width, w_height);
+
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.h_start, w_left, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.v_start, w_top, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.o_width, w_width, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.o_height, w_height, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.h_end, w_width, __FUNCTION__);
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.v_end, w_height, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Couldn't set sensor roi: (left: %u, top: %u, width: %u, height: %u) (error: %d)\n", __FUNCTION__,
+                        w_left, w_top, w_width, w_height, ret);
+                return ret;
+        }
+
+        return 0;
+}
+
+#ifdef READ_VMAX
+static __u32 vc_sen_read_vmax(struct vc_ctrl *ctrl)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        __u32 vmax = i2c_read_reg4(dev, client, &ctrl->csr.sen.vmax, __FUNCTION__);
+
+        vc_notice(dev, "%s(): Read sensor VMAX: 0x%08x (%u)\n", __FUNCTION__, vmax, vmax);
+
+        return vmax;
+}
+#endif
+
+// static __u32 vc_sen_read_hmax(struct vc_ctrl *ctrl)
+// {
+// 	struct i2c_client *client = ctrl->client_sen;
+// 	struct device *dev = &client->dev;
+// 	__u32 hmax = i2c_read_reg4(dev, client, &ctrl->csr.sen.hmax, __FUNCTION__);
+
+// 	vc_dbg(dev, "%s(): Read sensor HMAX: 0x%08x (%u)\n", __FUNCTION__, hmax, hmax);
+
+// 	return hmax;
+// }
+
+static int vc_sen_write_vmax(struct vc_ctrl *ctrl, __u32 vmax)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor VMAX: 0x%08x (%u)\n", __FUNCTION__, vmax, vmax);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.vmax, vmax, __FUNCTION__);
+}
+
+static int vc_sen_write_shs(struct vc_ctrl *ctrl, __u32 shs)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor SHS: 0x%08x (%u)\n", __FUNCTION__, shs, shs);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.shs, shs, __FUNCTION__);
+}
+
+static int vc_sen_write_flash_duration(struct vc_ctrl *ctrl, __u32 duration)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor flash duration: 0x%08x (%u)\n", __FUNCTION__, duration, duration);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.flash_duration, duration, __FUNCTION__);
+}
+
+static int vc_sen_write_flash_offset(struct vc_ctrl *ctrl, __u32 offset)
+{
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+
+        vc_dbg(dev, "%s(): Write sensor flash offset: 0x%08x (%u)\n", __FUNCTION__, offset, offset);
+
+        return i2c_write_reg4(dev, client, &ctrl->csr.sen.flash_offset, offset, __FUNCTION__);
+}
+
+int vc_sen_set_gain(struct vc_cam *cam, int gain)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        int ret = 0;
+
+        if (gain < ctrl->gain.min)
+                gain = ctrl->gain.min;
+        if (gain > ctrl->gain.max)
+                gain = ctrl->gain.max;
+
+        vc_notice(dev, "%s(): Set sensor gain: %u\n", __FUNCTION__, gain);
+
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.gain, gain, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Couldn't set gain (error: %d)\n", __FUNCTION__, ret);
+                return ret;
+        }
+
+        cam->state.gain = gain;
+        return 0;
+}
+
+int vc_sen_set_blacklevel(struct vc_cam *cam, int blacklevel)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct i2c_client *client = ctrl->client_sen;
+        struct device *dev = &client->dev;
+        int ret = 0;
+
+        if (blacklevel < ctrl->blacklevel.min)
+                blacklevel = ctrl->blacklevel.min;
+        if (blacklevel > ctrl->blacklevel.max)
+                blacklevel = ctrl->blacklevel.max;
+
+        vc_notice(dev, "%s(): Set sensor black level: %u\n", __FUNCTION__, blacklevel);
+
+        ret |= i2c_write_reg2(dev, client, &ctrl->csr.sen.blacklevel, blacklevel, __FUNCTION__);
+        if (ret) {
+                vc_err(dev, "%s(): Couldn't set black level (error: %d)\n", __FUNCTION__, ret);
+                return ret;
+        }
+
+        cam->state.blacklevel = blacklevel;
+        return 0;
+}
+
+int vc_sen_start_stream(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client_mod = ctrl->client_mod;
+        struct device *dev = &ctrl->client_sen->dev;
+        int ret = 0;
+
+        vc_notice(dev, "%s(): Start streaming\n", __FUNCTION__);
+        vc_dbg(dev, "%s(): MM: 0x%02x, TM: 0x%02x, IO: 0x%02x\n",
+                __FUNCTION__, state->mode, state->trigger_mode, state->io_mode);
+
+        if (state->streaming) {
+                vc_sen_stop_stream(cam);
+        }
+
+        ret |= vc_sen_write_mode(ctrl, ctrl->csr.sen.mode_operating);
+        if (ret)
+                vc_err(dev, "%s(): Unable to start streaming (error: %d)\n", __FUNCTION__, ret);
+
+        ret |= vc_mod_write_io_mode(client_mod, state->io_mode);
+        ret |= vc_mod_write_trigger_mode(client_mod, state->trigger_mode);
+
+        state->streaming = 1;
+
+        return ret;
+}
+
+int vc_sen_stop_stream(struct vc_cam *cam)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct i2c_client *client_mod = ctrl->client_mod;
+        struct device *dev = &ctrl->client_sen->dev;
+        int ret = 0;
+
+        vc_notice(dev, "%s(): Stop streaming\n", __FUNCTION__);
+
+        ret |= vc_mod_write_trigger_mode(client_mod, REG_TRIGGER_DISABLE);
+        ret |= vc_mod_write_io_mode(client_mod, REG_IO_DISABLE);
+
+        ret |= vc_sen_write_mode(ctrl, ctrl->csr.sen.mode_standby);
+        if (ret)
+                vc_err(dev, "%s(): Unable to stop streaming (error: %d)\n", __FUNCTION__, ret);
+
+        state->streaming = 0;
+
+        vc_dbg(dev, "%s(): ----------------------------------------------------------\n", __FUNCTION__);
+
+        return ret;
+}
+
+
+// ------------------------------------------------------------------------------------------------
+
+static __u32 vc_core_calculate_period_1H(struct vc_cam *cam, __u8 num_lanes, __u8 format)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        __u8 index = 0;
+
+        for (index = 0; index <= 7; index++) {
+                struct vc_timing *timing = &ctrl->expo_timing[index];
+                if (timing->num_lanes == num_lanes && timing->format == format) {
+                        return ((__u64)timing->hmax * 1000000000) / ctrl->clk_pixel;
+                }
+        }
+        return 0;
+}
+
+static void vc_core_calculate_vmax(struct vc_cam *cam, __u32 period_1H_ns)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        __u64 frametime_ns;
+        __u64 frametime_1H;
+
+        state->vmax = vc_core_get_optimized_vmax(cam);
+        // Lower the frame rate if the frame rate setting requires it.
+        if (state->framerate > 0) {
+                frametime_ns = 1000000000000 / state->framerate;
+                frametime_1H = frametime_ns / period_1H_ns;
+                if (frametime_1H > state->vmax) {
+                        state->vmax = frametime_1H;
+                }
+
+                vc_dbg(dev, "%s(): framerate: %u mHz, frametime: %llu ns, %llu 1H\n", __FUNCTION__,
+                        state->framerate, frametime_ns, frametime_1H);
+        }
+}
+
+static void vc_calculate_exposure_sony(struct vc_cam *cam, __u64 exposure_1H)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        __u32 shs_min = ctrl->vmax.min;
+
+        // Exposure time [s] = (1 H period) Ã (Number of lines per frame - SHS)
+        //                     + Exposure time error (t OFFSET ) [Âµs]
+
+        // Is exposure time less than frame time?
+        if (exposure_1H < state->vmax - shs_min) {
+                // Yes then calculate exposure delay (shs) in between frame time.
+                // |                 VMAX (frame time)             ---> |
+                // | SHS_MIN |                                          |
+                // +----------------------------+-----------------------+
+                // | SHS (exposure delay) --->  |    exposure time ---> |
+                state->shs = state->vmax - exposure_1H;
+
+        } else {
+                // No, then increase frame time and set exposure delay to the minimal value.
+                // |                 VMAX (frame time)                   ---> |
+                // +---------+------------------------------------------------+
+                // | SHS     |                             exposure time ---> |
+                state->vmax = shs_min + exposure_1H;
+                state->shs = shs_min;
+        }
+
+        // Special case: Framerate of slave module has to be a little bit faster (Tested with IMX183)
+        if (state->trigger_mode == REG_TRIGGER_SYNC) {
+                state->vmax--;
+        }
+}
+
+static void vc_calculate_exposure_normal(struct vc_cam *cam, __u64 exposure_1H)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        __u32 shs_min = ctrl->vmax.min;
+
+        // Is exposure time greater than shs_min and less than frame time?
+        if (shs_min <= exposure_1H && exposure_1H < state->vmax) {
+                // Yes then calculate exposure delay (shs) in between frame time.
+                // |                 VMAX (frame time)             ---> |
+                // +------------------------+---------------------------+
+                // | exposure time ---> SHS |                           |
+                state->shs = exposure_1H;
+
+        } else if (exposure_1H < shs_min) {
+                // Yes, then set shs equal to shs_min
+                // |                 VMAX (frame time)             ---> |
+                // +----------------------------+-----------------------+
+                // | SHS_MIN |                                          |
+                state->shs = shs_min;
+
+        } else {
+                // |                 VMAX (frame time)                   ---> |
+                // +----------------------------------------------------------+
+                // |                                       exposure time ---> |
+                state->vmax = exposure_1H;
+                state->shs = exposure_1H;
+        }
+}
+
+static void vc_calculate_exposure(struct vc_cam *cam, __u32 exposure_us)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        __u8 num_lanes = state->num_lanes;
+        __u8 format = vc_core_v4l2_code_to_format(state->format_code);
+        __u32 period_1H_ns = 0;
+        __u64 exposure_ns;
+        __u64 exposure_1H;
+
+        period_1H_ns = vc_core_calculate_period_1H(cam, num_lanes, format);
+        vc_core_calculate_vmax(cam, period_1H_ns);
+
+        // Convert exposure time from Âµs to ns.
+        exposure_ns = (__u64)(exposure_us)*1000;
+        // Calculate number of lines equivalent to the exposure time without shs_min.
+        exposure_1H = exposure_ns / period_1H_ns;
+
+        if (ctrl->flags & FLAG_EXPOSURE_SONY) {
+                vc_calculate_exposure_sony(cam, exposure_1H);
+
+        } else if (ctrl->flags & FLAG_EXPOSURE_NORMAL) {
+                vc_calculate_exposure_normal(cam, exposure_1H);
+        }
+
+        vc_dbg(dev, "%s(): flags: 0x%04x, period_1H_ns: %u, shs: %u/%u, vmax: %u/%u\n", __FUNCTION__,
+                ctrl->flags, period_1H_ns, state->shs, ctrl->vmax.min, state->vmax, ctrl->vmax.def);
+}
+
+static void vc_calculate_trig_exposure(struct vc_cam *cam, __u32 exposure_us)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = &ctrl->client_sen->dev;
+        // __u8 num_lanes = state->num_lanes;
+        // __u8 format = vc_core_v4l2_code_to_format(state->format_code);
+        __u32 min_frametime_us = 0;
+        __u32 frametime_us = 0;
+
+        // NOTE: Currently it is not possible to use an optimized minimal frame time.
+        // min_frametime_us = 1000000000 / vc_core_calculate_max_frame_rate(cam, num_lanes, format) + 1000;
+        min_frametime_us = ((__u64)ctrl->retrigger_min * 1000000) / ctrl->clk_ext_trigger;
+        frametime_us = min_frametime_us;
+
+        if (state->trigger_mode & REG_TRIGGER_SELF) {
+                if (state->framerate > 0) {
+                        frametime_us = 1000000000 / state->framerate;
+                }
+                if (frametime_us < min_frametime_us) {
+                        frametime_us = min_frametime_us;
+                }
+                if (ctrl->flags & FLAG_TRIGGER_SELF) {
+                        // NOTE: Currently it is not possible to adjust the frame time
+                        //       in respect to the exposure time.
+                        // if (exposure_us > (frametime_us - min_frametime_us)) {
+                        // 	frametime_us = exposure_us + min_frametime_us;
+                        // }
+
+                } else if(ctrl->flags & FLAG_TRIGGER_SELF_V2) {
+                        if (frametime_us >= exposure_us) {
+                                frametime_us -= exposure_us;
+                        } else {
+                                frametime_us = 1;
+                        }
+                }
+        }
+
+        vc_dbg(dev, "%s(): min_frametime: %u us, frametime: %u us, exposure: %u us\n", __FUNCTION__,
+                min_frametime_us, frametime_us, exposure_us);
+        state->retrigger_cnt = ((__u64)frametime_us * ctrl->clk_ext_trigger) / 1000000;
+        // NOTE: Check this for different cameras.
+        // if (state->retrigger_cnt < 3240) {
+        // 	state->retrigger_cnt = 3240;
+        // }
+        state->exposure_cnt = ((__u64)exposure_us * ctrl->clk_ext_trigger) / 1000000;
+}
+
+int vc_sen_set_exposure(struct vc_cam *cam, int exposure_us)
+{
+        struct vc_ctrl *ctrl = &cam->ctrl;
+        struct vc_state *state = &cam->state;
+        struct device *dev = vc_core_get_sen_device(cam);
+        struct i2c_client *client_mod = ctrl->client_mod;
+        int ret = 0;
+
+        vc_notice(dev, "%s(): Set sensor exposure: %u us\n", __FUNCTION__, exposure_us);
+
+        if (exposure_us < ctrl->exposure.min)
+                exposure_us = ctrl->exposure.min;
+        if (exposure_us > ctrl->exposure.max)
+                exposure_us = ctrl->exposure.max;
+
+        state->vmax = 0;
+        state->shs = 0;
+        state->exposure_cnt = 0;
+        state->retrigger_cnt = 0;
+
+        switch (state->trigger_mode) {
+        case REG_TRIGGER_EXTERNAL:
+        case REG_TRIGGER_SINGLE:
+        case REG_TRIGGER_SELF:
+                vc_calculate_trig_exposure(cam, exposure_us);
+                ret |= vc_mod_write_exposure(client_mod, state->exposure_cnt);
+                // NOTE for FLAG_TRIGGER_SELF
+                // - Changing retrigger from bigger to smaller values leads to a hang up of the camera.
+                // - Changing exposure isn't applied sometimes
+                if (!state->streaming || ctrl->flags & FLAG_TRIGGER_SELF_V2) {
+                        ret |= vc_mod_write_retrigger(client_mod, state->retrigger_cnt);
+                }
+                break;
+        case REG_TRIGGER_PULSEWIDTH:
+                break;
+        case REG_TRIGGER_DISABLE:
+        case REG_TRIGGER_SYNC:
+        case REG_TRIGGER_STREAM_EDGE:
+        case REG_TRIGGER_STREAM_LEVEL:
+                vc_calculate_exposure(cam, exposure_us);
+                ret |= vc_sen_write_shs(ctrl, state->shs);
+                ret |= vc_sen_write_vmax(ctrl, state->vmax);
+        }
+
+        if (ctrl->flags & FLAG_SET_FLASH_DURATION) {
+                __u32 duration = (((__u64)exposure_us)*ctrl->flash_factor)/1000000;
+                ret |= vc_sen_write_flash_duration(ctrl, duration);
+                ret |= vc_sen_write_flash_offset(ctrl, ctrl->flash_toffset);
+        }
+
+        if (ret == 0) {
+                cam->state.exposure = exposure_us;
+        }
+
+        vc_dbg(dev, "%s(): (VMAX: %5u, SHS: %5u), (RETC: %6u, EXPC: %6u)\n",
+                __FUNCTION__, state->vmax, state->shs, state->retrigger_cnt, state->exposure_cnt);
+
+        return ret;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/vc_mipi_core.h b/drivers/media/i2c/vc_mipi_core.h
new file mode 100755
index 000000000000..3bfcef6a0716
--- /dev/null
+++ b/drivers/media/i2c/vc_mipi_core.h
@@ -0,0 +1,242 @@
+#ifndef _VC_MIPI_CORE_H
+#define _VC_MIPI_CORE_H
+
+// #define DEBUG
+
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/videodev2.h>
+
+#define vc_dbg(dev, fmt, ...) dev_dbg(dev, fmt, ##__VA_ARGS__)
+#define vc_info(dev, fmt, ...) dev_info(dev, fmt, ##__VA_ARGS__)
+#define vc_notice(dev, fmt, ...) dev_notice(dev, fmt, ##__VA_ARGS__)
+#define vc_warn(dev, fmt, ...) dev_warn(dev, fmt, ##__VA_ARGS__)
+#define vc_err(dev, fmt, ...) dev_err(dev, fmt, ##__VA_ARGS__)
+
+#define FLAG_RESET_ALWAYS		(1 <<  0)
+#define FLAG_EXPOSURE_SONY      	(1 <<  1)
+#define FLAG_EXPOSURE_NORMAL    	(1 <<  2)
+#define FLAG_SET_FLASH_DURATION		(1 <<  3)
+
+#define FLAG_IO_ENABLED           	(1 <<  4)
+#define FLAG_FORMAT_GBRG		(1 <<  5)
+#define FLAG_DOUBLE_HEIGHT        	(1 <<  6)
+#define FLAG_INCREASE_FRAME_RATE       	(1 <<  7)
+
+#define FLAG_TRIGGER_DISABLE      	(1 <<  8)
+#define FLAG_TRIGGER_EXTERNAL     	(1 <<  9)
+#define FLAG_TRIGGER_PULSEWIDTH   	(1 << 10)
+#define FLAG_TRIGGER_SELF         	(1 << 11)
+#define FLAG_TRIGGER_SELF_V2         	(1 << 12)
+#define FLAG_TRIGGER_SINGLE  	  	(1 << 13)
+#define FLAG_TRIGGER_SYNC         	(1 << 14)
+#define FLAG_TRIGGER_STREAM_EDGE  	(1 << 15)
+#define FLAG_TRIGGER_STREAM_LEVEL 	(1 << 16)
+#define FLAG_TRIGGER_SLAVE       	(1 << 17)
+
+#define FORMAT_RAW08			0x2a
+#define FORMAT_RAW10			0x2b
+#define FORMAT_RAW12			0x2c
+#define FORMAT_RAW14			0x2d
+
+
+struct vc_desc_mode {
+        __u8 data_rate[4];
+        __u8 num_lanes;
+        __u8 format;
+        __u8 type;
+        __u8 binning;
+        __u8 reserved2[8];
+};
+
+struct vc_desc {
+        // Module description
+        __u8 magic[12];
+        __u8 manuf[32];
+        __u16 manuf_id;
+        __u8 sen_manuf[8];
+        __u8 sen_type[16];
+        __u16 mod_id;
+        __u16 mod_rev;
+        __u16 chip_id_high;
+        __u16 chip_id_low;
+        __u16 chip_rev;
+        // Sensor registers
+        __u16 csr_mode;
+        __u16 csr_h_start_h;
+        __u16 csr_h_start_l;
+        __u16 csr_v_start_h;
+        __u16 csr_v_start_l;
+        __u16 csr_h_end_h;
+        __u16 csr_h_end_l;
+        __u16 csr_v_end_h;
+        __u16 csr_v_end_l;
+        __u16 csr_o_width_h;
+        __u16 csr_o_width_l;
+        __u16 csr_o_height_h;
+        __u16 csr_o_height_l;
+        __u16 csr_exposure_h;
+        __u16 csr_exposure_m;
+        __u16 csr_exposure_l;
+        __u16 csr_gain_h;
+        __u16 csr_gain_l;
+        // Exposure Settings
+        __u32 clk_ext_trigger;
+        __u32 clk_pixel;
+        __u16 shutter_offset;
+        // Reserved
+        __u8 reserved[4];
+        // Modes
+        __u16 num_modes;
+        __u16 bytes_per_mode;
+        struct vc_desc_mode modes[24];
+};
+
+typedef struct vc_control {
+        __u32 min;
+        __u32 max;
+        __u32 def;
+} vc_control;
+
+typedef struct vc_frame {
+        __u32 left;
+        __u32 top;
+        __u32 width;
+        __u32 height;
+} vc_frame;
+
+typedef struct vc_csr2 {
+        __u32 l;
+        __u32 m;
+} vc_csr2;
+
+typedef struct vc_csr4 {
+        __u32 l;
+        __u32 m;
+        __u32 h;
+        __u32 u;
+} vc_csr4;
+
+struct vc_sen_csr {
+        struct vc_csr2 mode;
+        __u8 mode_standby;
+        __u8 mode_operating;
+        struct vc_csr4 vmax;
+        struct vc_csr4 hmax;
+        struct vc_csr4 shs;
+        struct vc_csr2 gain;
+        struct vc_csr2 blacklevel;
+        struct vc_csr2 h_start;
+        struct vc_csr2 v_start;
+        struct vc_csr2 h_end;
+        struct vc_csr2 v_end;
+        struct vc_csr2 o_width;
+        struct vc_csr2 o_height;
+        struct vc_csr4 flash_duration;
+        struct vc_csr4 flash_offset;
+};
+
+struct vc_csr {
+        struct vc_sen_csr sen;
+};
+
+typedef struct vc_timing {
+        __u8 num_lanes;
+        __u8 format;
+        __u32 hmax;
+} vc_timing;
+
+struct vc_ctrl {
+        // Communication
+        int mod_i2c_addr;
+        struct i2c_client *client_sen;
+        struct i2c_client *client_mod;
+        // Controls
+        struct vc_control vmax;
+        struct vc_control exposure;
+        struct vc_control gain;
+        struct vc_control framerate;
+        struct vc_control blacklevel;
+        // Modes & Frame Formats
+        struct vc_frame frame;		// Pixel
+        // Control and status registers
+        struct vc_csr csr;
+        // Exposure
+        struct vc_timing expo_timing[8];
+        __u32 clk_ext_trigger;		// Hz
+        __u32 clk_pixel;		// Hz
+        __u32 retrigger_min;
+        // Flash
+        __u32 flash_factor;
+        __s32 flash_toffset;
+        // Special features
+        __u32 flags;
+};
+
+struct vc_state {
+        __u8 mode;
+        __u32 vmax;
+        __u32 shs;
+        __u32 exposure;			// Âµs
+        __u32 gain;
+        __u32 blacklevel;
+        __u32 exposure_cnt;
+        __u32 retrigger_cnt;
+        __u32 framerate;
+        __u32 format_code;
+        struct vc_frame frame;		// Pixel
+        __u8 num_lanes;
+        __u8 io_mode;
+        __u8 trigger_mode;
+        int power_on;
+        int streaming;
+        __u8 flags;
+};
+
+struct vc_cam {
+        struct vc_desc desc;
+        struct vc_ctrl ctrl;
+        struct vc_state state;
+};
+
+// --- Helper functions to allow i2c communication for customization ----------
+int vc_read_i2c_reg(struct i2c_client *client, const __u16 addr);
+int vc_write_i2c_reg(struct i2c_client *client, const __u16 addr, const __u8 value);
+
+// --- Helper functions for internal data structures --------------------------
+void vc_core_print_debug(struct vc_cam *cam);
+struct device *vc_core_get_sen_device(struct vc_cam *cam);
+struct device *vc_core_get_mod_device(struct vc_cam *cam);
+int vc_core_try_format(struct vc_cam *cam, __u32 code);
+int vc_core_set_format(struct vc_cam *cam, __u32 code);
+__u32 vc_core_get_format(struct vc_cam *cam);
+int vc_core_set_frame(struct vc_cam *cam, __u32 x, __u32 y, __u32 width, __u32 height);
+struct vc_frame *vc_core_get_frame(struct vc_cam *cam);
+int vc_core_set_num_lanes(struct vc_cam *cam, __u32 number);
+__u32 vc_core_get_num_lanes(struct vc_cam *cam);
+int vc_core_set_framerate(struct vc_cam *cam, __u32 framerate);
+__u32 vc_core_get_framerate(struct vc_cam *cam);
+
+// --- Function to initialize the vc core --------------------------------------
+int vc_core_init(struct vc_cam *cam, struct i2c_client *client);
+int vc_core_update_controls(struct vc_cam *cam);
+
+// --- Functions for the VC MIPI Controller Module ----------------------------
+int vc_mod_set_mode(struct vc_cam *cam, int *reset);
+int vc_mod_is_trigger_enabled(struct vc_cam *cam);
+int vc_mod_set_trigger_mode(struct vc_cam *cam, int mode);
+int vc_mod_get_trigger_mode(struct vc_cam *cam);
+int vc_mod_set_single_trigger(struct vc_cam *cam);
+int vc_mod_is_io_enabled(struct vc_cam *cam);
+int vc_mod_set_io_mode(struct vc_cam *cam, int mode);
+int vc_mod_get_io_mode(struct vc_cam *cam);
+
+// --- Functions for the VC MIPI Sensors --------------------------------------
+int vc_sen_set_roi(struct vc_cam *cam);
+int vc_sen_set_exposure(struct vc_cam *cam, int exposure);
+int vc_sen_set_gain(struct vc_cam *cam, int gain);
+int vc_sen_set_blacklevel(struct vc_cam *cam, int blacklevel);
+int vc_sen_start_stream(struct vc_cam *cam);
+int vc_sen_stop_stream(struct vc_cam *cam);
+
+#endif // _VC_MIPI_CORE_H
\ No newline at end of file
diff --git a/drivers/media/i2c/vc_mipi_modules.c b/drivers/media/i2c/vc_mipi_modules.c
new file mode 100644
index 000000000000..ddb21834abcf
--- /dev/null
+++ b/drivers/media/i2c/vc_mipi_modules.c
@@ -0,0 +1,703 @@
+#include "vc_mipi_modules.h"
+#include <linux/v4l2-mediabus.h>
+
+
+int vc_mod_is_color_sensor(struct vc_desc *desc)
+{
+        if (desc->sen_type) {
+                __u32 len = strnlen(desc->sen_type, 16);
+                if (len > 0 && len < 17) {
+                        return *(desc->sen_type + len - 1) == 'C';
+                }
+        }
+        return 0;
+}
+
+static void vc_init_ctrl(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->exposure			= (vc_control) { .min =   1, .max = 100000000, .def =  10000 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =       255, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =       255, .def =      0 };
+        ctrl->framerate 		= (vc_control) { .min =   0, .max =   1000000, .def =      0 };
+
+        ctrl->csr.sen.mode 		= (vc_csr2) { .l = desc->csr_mode, .m = 0x0000 };
+
+        ctrl->csr.sen.mode_standby	= 0x00;
+        ctrl->csr.sen.mode_operating	= 0x01;
+
+        ctrl->csr.sen.shs.l 		= desc->csr_exposure_l;
+        ctrl->csr.sen.shs.m 		= desc->csr_exposure_m;
+        ctrl->csr.sen.shs.h 		= desc->csr_exposure_h;
+        ctrl->csr.sen.shs.u 		= 0;
+
+        ctrl->csr.sen.gain.l 		= desc->csr_gain_l;
+        ctrl->csr.sen.gain.m 		= desc->csr_gain_h;
+
+        ctrl->csr.sen.h_start.l 	= desc->csr_h_start_l;
+        ctrl->csr.sen.h_start.m 	= desc->csr_h_start_h;
+        ctrl->csr.sen.v_start.l 	= desc->csr_v_start_l;
+        ctrl->csr.sen.v_start.m 	= desc->csr_v_start_h;
+        ctrl->csr.sen.h_end.l 		= desc->csr_h_end_l;
+        ctrl->csr.sen.h_end.m 		= desc->csr_h_end_h;
+        ctrl->csr.sen.v_end.l 		= desc->csr_v_end_l;
+        ctrl->csr.sen.v_end.m 		= desc->csr_v_end_h;
+        ctrl->csr.sen.o_width.l		= desc->csr_o_width_l;
+        ctrl->csr.sen.o_width.m		= desc->csr_o_width_h;
+        ctrl->csr.sen.o_height.l	= desc->csr_o_height_l;
+        ctrl->csr.sen.o_height.m	= desc->csr_o_height_h;
+
+        ctrl->frame.left		= 0;
+        ctrl->frame.top			= 0;
+
+        ctrl->clk_ext_trigger		= desc->clk_ext_trigger;
+        ctrl->clk_pixel			= desc->clk_pixel;
+}
+
+static void vc_init_ctrl_imx183_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x7004, .m = 0x7005, .h = 0x7006, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x7002, .m = 0x7003, .h = 0x0000, .u = 0x0000 };
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_SELF |
+                                          FLAG_TRIGGER_SINGLE | FLAG_TRIGGER_SYNC;
+}
+
+static void vc_init_ctrl_imx252_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->gain			= (vc_control) { .min =   0, .max =       511, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =      4095, .def =     60 };
+
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x0210, .m = 0x0211, .h = 0x0212, .u = 0x0000 };
+        ctrl->csr.sen.hmax              = (vc_csr4) { .l = 0x0214, .m = 0x0215, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0454, .m = 0x0455 };
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+static void vc_init_ctrl_imx290_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->vmax			= (vc_control) { .min =   1, .max =   0x3ffff, .def =   1125 };
+        ctrl->exposure			= (vc_control) { .min =   1, .max =  15000000, .def =  10000 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =       255, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =       511, .def =  0x0f0 };
+
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3018, .m = 0x3019, .h = 0x301A, .u = 0x0000 };
+        ctrl->csr.sen.mode_standby	= 0x01;
+        ctrl->csr.sen.mode_operating	= 0x00;
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x300a, .m = 0x300b };
+
+        ctrl->frame.width		= 1920;
+        ctrl->frame.height		= 1080;
+
+        ctrl->clk_ext_trigger           = 74250000;
+        ctrl->clk_pixel                 = 74250000;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+}
+
+static void vc_init_ctrl_imx296_base(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        ctrl->vmax			= (vc_control) { .min =   5, .max =   0xfffff, .def =   1110 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =       480, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =     0xfff, .def =     60 };
+
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3010, .m = 0x3011, .h = 0x3012, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x300A };
+        ctrl->csr.sen.mode_standby	= 0x01;
+        ctrl->csr.sen.mode_operating	= 0x00;
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3254, .m = 0x3255 };
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 1, FORMAT_RAW10, .hmax =  1100 };
+
+        ctrl->retrigger_min		= 0x000d7940;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH | FLAG_TRIGGER_SELF_V2;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX178/IMX178C  (Rev.01)
+
+static void vc_init_ctrl_imx178(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX178\n", __FUNCTION__);
+
+        vc_init_ctrl_imx183_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =   9, .max =   0x1ffff, .def =   2126 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =       480, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =     0x3ff, .def =     60 };
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3015, .m = 0x3016 };
+
+        ctrl->frame.width		= 3072;
+        ctrl->frame.height		= 2048;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  680 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  840 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  984 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 2, FORMAT_RAW14, .hmax = 1156 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  600 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  600 };
+        ctrl->expo_timing[6] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  680 };
+        ctrl->expo_timing[7] 		= (vc_timing) { 4, FORMAT_RAW14, .hmax = 1156 };
+
+        ctrl->retrigger_min		= 0x00292d40;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX183/IMX183C (Rev.12)
+
+static void vc_init_ctrl_imx183(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX183\n", __FUNCTION__);
+
+        vc_init_ctrl_imx183_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =   5, .max =   0x1ffff, .def =   3728 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =     0x7a5, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =      0xff, .def =   0x32 };
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0045, .m = 0x0000 };
+
+        ctrl->frame.width		= 5440;
+        ctrl->frame.height		= 3648;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax = 1440 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax = 1440 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax = 1724 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  720 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  720 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  862 };
+
+        ctrl->retrigger_min		= 0x0036ee7d;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX226/IMX226C (Rev.13)
+
+static void vc_init_ctrl_imx226(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX226\n", __FUNCTION__);
+
+        vc_init_ctrl_imx183_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =   5, .max =   0x1ffff, .def =   3079 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =     0x7a5, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =       255, .def =     50 };
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x0045, .m = 0x0000 };
+
+        ctrl->frame.width		= 3904;
+        ctrl->frame.height		= 3000;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax = 1072 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax = 1072 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax = 1288 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  536 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  536 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  644 };
+
+        ctrl->clk_pixel                 = 72000000;
+        ctrl->retrigger_min		= 0x00292d40;
+
+        ctrl->flags		       |= FLAG_FORMAT_GBRG;
+        ctrl->flags                    |= FLAG_TRIGGER_STREAM_EDGE | FLAG_TRIGGER_STREAM_LEVEL;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX250/IMX250C (Rev.07)
+
+static void vc_init_ctrl_imx250(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX250\n", __FUNCTION__);
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =  10, .max =   0xfffff, .def =   2094 };
+
+        ctrl->frame.width		= 2432;
+        ctrl->frame.height		= 2048;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  540 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  660 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  780 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  350 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  430 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  510 };
+
+        ctrl->retrigger_min		= 0x00181c08;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX252/IMX252C (Rev.10)
+
+static void vc_init_ctrl_imx252(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX252\n", __FUNCTION__);
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =  10, .max =   0xfffff, .def =   1582 };
+
+        ctrl->frame.width		= 2048;
+        ctrl->frame.height		= 1536;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  460 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  560 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  672 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  310 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  380 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  444 };
+
+        ctrl->retrigger_min		= 0x00103b4a;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX264/IMX264C (Rev.03)
+
+static void vc_init_ctrl_imx264(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX264\n", __FUNCTION__);
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =  10, .max =   0xfffff, .def =   2100 };
+
+        ctrl->frame.width		= 2432;
+        ctrl->frame.height		= 2048;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  996 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  996 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  996 };
+
+        ctrl->retrigger_min		= 0x00181c08;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX265/IMX265C (Rev.01)
+
+static void vc_init_ctrl_imx265(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX265\n", __FUNCTION__);
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =  10, .max =   0xfffff, .def =   1587 };
+
+        ctrl->frame.width		= 2048;
+        ctrl->frame.height		= 1536;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  846 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  846 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  846 };
+
+        ctrl->retrigger_min		= 0x00181c08;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX273/IMX273C (Rev.13)
+
+static void vc_init_ctrl_imx273(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX273\n", __FUNCTION__);
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =  15, .max =   0xfffff, .def =   1130 };
+
+        ctrl->frame.width		= 1440;
+        ctrl->frame.height		= 1080;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  336 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  420 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  480 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  238 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  290 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  396 };
+
+        ctrl->retrigger_min		= 0x0007ec3e;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX290 (Rev.02)
+
+static void vc_init_ctrl_imx290(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX290\n", __FUNCTION__);
+
+        vc_init_ctrl_imx290_base(ctrl, desc);
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  550 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  550 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  550 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  550 };
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX296/IMX296C (Rev.42)
+
+static void vc_init_ctrl_imx296(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX296\n", __FUNCTION__);
+
+        vc_init_ctrl_imx296_base(ctrl, desc);
+
+        ctrl->frame.width		= 1440;
+        ctrl->frame.height		= 1080;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX297 (Rev.??)
+
+static void vc_init_ctrl_imx297(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX297\n", __FUNCTION__);
+
+        vc_init_ctrl_imx296_base(ctrl, desc);
+
+        ctrl->frame.width		= 720;
+        ctrl->frame.height		= 540;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX327C (Rev.02)
+//
+// NOTES:
+// - For vertical flipping VREVERSE 0x3007 = 0x01 has to be set.
+// - For horizontal flipping HREVERSE 0x3007 = 0x02 has to be set.
+// - For cropping WINMODE 0x3007 = 0x40 has to be set. Unfortunatly cropping mode does not reduce
+//   the image size. The image is always filled up to a size of 1920x1080.
+// - To increase the frame rate it is possible to reduce VMAX. In this case the image height is forced
+//   to be height = VMAX - 15. This is independend of the cropped image height.
+// => Cropping is not properly supported.
+// => Frame rate increase by image height reduction could be implemented.
+//    But, it need an own implementation.
+
+static void vc_init_ctrl_imx327(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX327\n", __FUNCTION__);
+
+        vc_init_ctrl_imx290_base(ctrl, desc);
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  1100 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  1100 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  1100 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  1100 };
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX335 (Rev.00)
+//
+//  TODO:
+//  - Max. Framerate of 19.5 fps is to low. Has to be 60 fps
+
+static void vc_init_ctrl_imx335(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX335\n", __FUNCTION__);
+
+        ctrl->vmax			= (vc_control) { .min =   9, .max =   0xfffff, .def =   4500 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =      0xff, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =     0x3ff, .def =   0x32 };
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x3302, .m = 0x3303 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3030, .m = 0x3031, .h = 0x3032, .u = 0x0000 };
+        ctrl->csr.sen.mode_standby	= 0x01;
+        ctrl->csr.sen.mode_operating	= 0x00;
+
+        ctrl->frame.left		= 7;
+        ctrl->frame.top			= 52;
+        ctrl->frame.width		= 2592;
+        ctrl->frame.height		= 1944;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =   916 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =   916 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =   614 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =   614 };
+
+        ctrl->flags		       |= FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags		       |= FLAG_DOUBLE_HEIGHT;
+        ctrl->flags		       |= FLAG_IO_ENABLED;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX392/IMX392C (Rev.06)
+
+static void vc_init_ctrl_imx392(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX392\n", __FUNCTION__);
+
+        vc_init_ctrl_imx252_base(ctrl, desc);
+
+        ctrl->vmax			= (vc_control) { .min =  10, .max =   0xfffff, .def =   1252 };
+
+        ctrl->frame.width		= 1920;
+        ctrl->frame.height		= 1200;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW08, .hmax =  448 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  530 };
+        ctrl->expo_timing[2] 		= (vc_timing) { 2, FORMAT_RAW12, .hmax =  624 };
+        ctrl->expo_timing[3] 		= (vc_timing) { 4, FORMAT_RAW08, .hmax =  294 };
+        ctrl->expo_timing[4] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  355 };
+        ctrl->expo_timing[5] 		= (vc_timing) { 4, FORMAT_RAW12, .hmax =  441 };
+
+        ctrl->retrigger_min		= 0x00103b4a;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX412C (Rev.02)
+//
+//  NOTES:
+//  - No TRIGGER and FLASH capability.
+//  TODO:
+//  - Slave Mode not implemented.
+
+static void vc_init_ctrl_imx412(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX412\n", __FUNCTION__);
+
+        ctrl->vmax			= (vc_control) { .min =  10, .max =    0xffff, .def = 0x0c14 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =      1023, .def =      0 };
+
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x0341, .m = 0x0340, .h = 0x0000, .u = 0x0000 };
+        ctrl->csr.sen.shs               = (vc_csr4) { .l = 0x0203, .m = 0x0202, .h = 0x0000, .u = 0x0000 };
+
+        ctrl->frame.width		= 4032;
+        ctrl->frame.height		= 3040;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax =  436 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  218 };
+
+        ctrl->clk_ext_trigger		= 27000000;
+        ctrl->clk_pixel			= 27000000;
+
+        ctrl->flags			= FLAG_RESET_ALWAYS;
+        ctrl->flags		       |= FLAG_EXPOSURE_NORMAL;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags		       |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_SLAVE;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX415C (Rev.01)
+
+static void vc_init_ctrl_imx415(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX415\n", __FUNCTION__);
+
+        ctrl->vmax			= (vc_control) { .min =   8, .max =   0xfffff, .def =  0x8ca };
+        ctrl->gain			= (vc_control) { .min =   0, .max =       240, .def =      0 };
+        ctrl->blacklevel		= (vc_control) { .min =   0, .max =     0x3ff, .def =   0x32 };
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x30e2, .m = 0x30e3 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x3024, .m = 0x3025, .h = 0x3026, .u = 0x0000 };
+        ctrl->csr.sen.mode_standby	= 0x01;
+        ctrl->csr.sen.mode_operating	= 0x00;
+
+        ctrl->frame.width		= 3840;
+        ctrl->frame.height		= 2160;
+
+        ctrl->expo_timing[0] 		= (vc_timing) { 2, FORMAT_RAW10, .hmax = 1042 };
+        ctrl->expo_timing[1] 		= (vc_timing) { 4, FORMAT_RAW10, .hmax =  551 };
+
+        ctrl->clk_pixel			= 74250000;
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags		       |= FLAG_DOUBLE_HEIGHT;
+        ctrl->flags		       |= FLAG_FORMAT_GBRG;
+        ctrl->flags		       |= FLAG_IO_ENABLED;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for IMX568 (Rev.01)
+
+static void vc_init_ctrl_imx568(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for IMX568\n", __FUNCTION__);
+
+        ctrl->vmax			= (vc_control) { .min =  42, .max =  0xffffff, .def =  0x8aa };
+        ctrl->gain                      = (vc_control) { .min =   0, .max =       480, .def =      0 };
+        ctrl->blacklevel 		= (vc_control) { .min =   0, .max =      4095, .def =   0x3c };
+
+        ctrl->csr.sen.blacklevel        = (vc_csr2) { .l = 0x35b4, .m = 0x35b5 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x30d4, .m = 0x30d5, .h = 0x30d6, .u = 0x0000 };
+        ctrl->csr.sen.mode              = (vc_csr2) { .l = 0x3000, .m = 0x3010 };
+        ctrl->csr.sen.mode_standby      = 0x01;
+        ctrl->csr.sen.mode_operating    = 0x00;
+
+        ctrl->frame.width               = 2472;
+        ctrl->frame.height              = 2048;
+
+        ctrl->expo_timing[0]            = (vc_timing) { 2, FORMAT_RAW08, .hmax =  489 };
+        ctrl->expo_timing[1]            = (vc_timing) { 2, FORMAT_RAW10, .hmax =  590 };
+        ctrl->expo_timing[2]            = (vc_timing) { 2, FORMAT_RAW12, .hmax =  703 };
+        ctrl->expo_timing[3]            = (vc_timing) { 4, FORMAT_RAW08, .hmax =  253 };
+        ctrl->expo_timing[4]            = (vc_timing) { 4, FORMAT_RAW10, .hmax =  309 };
+        ctrl->expo_timing[5]            = (vc_timing) { 4, FORMAT_RAW12, .hmax =  365 };
+
+        ctrl->flags                     = FLAG_EXPOSURE_SONY;
+        ctrl->flags                    |= FLAG_INCREASE_FRAME_RATE;
+        ctrl->flags                    |= FLAG_IO_ENABLED;
+        ctrl->flags                    |= FLAG_TRIGGER_EXTERNAL | FLAG_TRIGGER_PULSEWIDTH |
+                                          FLAG_TRIGGER_SELF | FLAG_TRIGGER_SINGLE;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for OV7251 (Rev.01)
+//
+//  TODO:
+//  - No flash out
+
+static void vc_init_ctrl_ov7251(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for OV7251\n", __FUNCTION__);
+
+        ctrl->vmax			= (vc_control) { .min =   0, .max =    0xffff, .def =    598 };
+        ctrl->exposure			= (vc_control) { .min =   1, .max =   1000000, .def =  10000 };
+        ctrl->gain			= (vc_control) { .min =   0, .max =      1023, .def =      0 };
+
+        ctrl->csr.sen.h_end 		= (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.v_end 		= (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.flash_duration	= (vc_csr4) { .l = 0x3b8f, .m = 0x3b8e, .h = 0x3b8d, .u = 0x3b8c };
+        ctrl->csr.sen.flash_offset	= (vc_csr4) { .l = 0x3b8b, .m = 0x3b8a, .h = 0x3b89, .u = 0x3b88 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x380f, .m = 0x380e, .h = 0x0000, .u = 0x0000 };
+        // NOTE: Modules rom table contains swapped address assigment.
+        ctrl->csr.sen.gain 		= (vc_csr2) { .l = 0x350b, .m = 0x350a };
+
+        ctrl->frame.width		= 640;
+        ctrl->frame.height		= 480;
+
+        ctrl->expo_timing[0]            = (vc_timing) { 1, FORMAT_RAW08, .hmax =  772 };
+        ctrl->expo_timing[1]            = (vc_timing) { 1, FORMAT_RAW10, .hmax =  772 };
+
+        ctrl->flash_factor		= 1758241 >> 4; // (1000 << 4)/9100 >> 4
+        ctrl->flash_toffset		= 4;
+
+        ctrl->flags		 	= FLAG_EXPOSURE_NORMAL;
+        ctrl->flags		       |= FLAG_IO_ENABLED | FLAG_SET_FLASH_DURATION;
+}
+
+// ------------------------------------------------------------------------------------------------
+//  Settings for OV9281 (Rev.02)
+//
+//  TODO:
+//  - Trigger mode could not be activated.
+//    - Additionally: When 0x0108 = 0x01 => exposure time has no effect.
+
+static void vc_init_ctrl_ov9281(struct vc_ctrl *ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_notice(dev, "%s(): Initialising module control for OV9281\n", __FUNCTION__);
+
+        ctrl->vmax			= (vc_control) { .min =  16, .max =    0xffff, .def =    910 };
+        ctrl->exposure			= (vc_control) { .min = 146, .max =    595000, .def =  10000 };
+        ctrl->gain			= (vc_control) { .min =  16, .max =       255, .def =     16 };
+
+        ctrl->csr.sen.h_end 		= (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.v_end 		= (vc_csr2) { .l = 0x0000, .m = 0x0000 };
+        ctrl->csr.sen.flash_duration	= (vc_csr4) { .l = 0x3928, .m = 0x3927, .h = 0x3926, .u = 0x3925 };
+        ctrl->csr.sen.flash_offset	= (vc_csr4) { .l = 0x3924, .m = 0x3923, .h = 0x3922, .u = 0x0000 };
+        ctrl->csr.sen.vmax              = (vc_csr4) { .l = 0x380f, .m = 0x380e, .h = 0x0000, .u = 0x0000 };
+        // NOTE: Modules rom table contains swapped address assigment.
+        ctrl->csr.sen.gain 		= (vc_csr2) { .l = 0x3509, .m = 0x0000 };
+
+        ctrl->frame.width		= 1280;
+        ctrl->frame.height		= 800;
+
+        ctrl->expo_timing[0]            = (vc_timing) { 2, FORMAT_RAW08, .hmax =  227 };
+        ctrl->expo_timing[1]            = (vc_timing) { 2, FORMAT_RAW10, .hmax =  227 };
+
+        ctrl->clk_ext_trigger		= 25000000;
+        ctrl->clk_pixel			= 25000000;
+
+        ctrl->flash_factor		= 1758241 >> 4; // (1000 << 4)/9100 >> 4
+        ctrl->flash_toffset		= 4;
+
+        ctrl->flags		 	= FLAG_EXPOSURE_NORMAL;
+        ctrl->flags		       |= FLAG_IO_ENABLED | FLAG_SET_FLASH_DURATION;
+        ctrl->flags		       |= FLAG_TRIGGER_EXTERNAL;
+}
+
+
+int vc_mod_ctrl_init(struct vc_ctrl* ctrl, struct vc_desc* desc)
+{
+        struct device *dev = &ctrl->client_mod->dev;
+
+        vc_init_ctrl(ctrl, desc);
+
+        switch(desc->mod_id) {
+        case MOD_ID_IMX178: vc_init_ctrl_imx178(ctrl, desc); break;
+        case MOD_ID_IMX183: vc_init_ctrl_imx183(ctrl, desc); break;
+        case MOD_ID_IMX226: vc_init_ctrl_imx226(ctrl, desc); break;
+        case MOD_ID_IMX250: vc_init_ctrl_imx250(ctrl, desc); break;
+        case MOD_ID_IMX252: vc_init_ctrl_imx252(ctrl, desc); break;
+        case MOD_ID_IMX264: vc_init_ctrl_imx264(ctrl, desc); break;
+        case MOD_ID_IMX265: vc_init_ctrl_imx265(ctrl, desc); break;
+        case MOD_ID_IMX273: vc_init_ctrl_imx273(ctrl, desc); break;
+        case MOD_ID_IMX290: vc_init_ctrl_imx290(ctrl, desc); break;
+        case MOD_ID_IMX296: vc_init_ctrl_imx296(ctrl, desc); break;
+        case MOD_ID_IMX297: vc_init_ctrl_imx297(ctrl, desc); break;
+        case MOD_ID_IMX327: vc_init_ctrl_imx327(ctrl, desc); break;
+        case MOD_ID_IMX335: vc_init_ctrl_imx335(ctrl, desc); break;
+        case MOD_ID_IMX392: vc_init_ctrl_imx392(ctrl, desc); break;
+        case MOD_ID_IMX412: vc_init_ctrl_imx412(ctrl, desc); break;
+        case MOD_ID_IMX415: vc_init_ctrl_imx415(ctrl, desc); break;
+        case MOD_ID_IMX568: vc_init_ctrl_imx568(ctrl, desc); break;
+        case MOD_ID_OV7251: vc_init_ctrl_ov7251(ctrl, desc); break;
+        case MOD_ID_OV9281: vc_init_ctrl_ov9281(ctrl, desc); break;
+        default:
+                vc_err(dev, "%s(): Detected module not supported!\n", __FUNCTION__);
+                return 1;
+        }
+
+        return 0;
+}
\ No newline at end of file
diff --git a/drivers/media/i2c/vc_mipi_modules.h b/drivers/media/i2c/vc_mipi_modules.h
new file mode 100644
index 000000000000..2f1223498aa9
--- /dev/null
+++ b/drivers/media/i2c/vc_mipi_modules.h
@@ -0,0 +1,29 @@
+#ifndef _VC_MIPI_MODULES_H
+#define _VC_MIPI_MODULES_H
+
+#include "vc_mipi_core.h"
+
+#define MOD_ID_IMX178           0x0178
+#define MOD_ID_IMX183           0x0183
+#define MOD_ID_IMX226           0x0226
+#define MOD_ID_IMX264           0x0264
+#define MOD_ID_IMX265           0x0265
+#define MOD_ID_IMX250           0x0250
+#define MOD_ID_IMX252           0x0252
+#define MOD_ID_IMX273           0x0273
+#define MOD_ID_IMX290           0x0290
+#define MOD_ID_IMX296           0x0296
+#define MOD_ID_IMX297           0x0297
+#define MOD_ID_IMX327           0x0327
+#define MOD_ID_IMX335           0x0335
+#define MOD_ID_IMX392           0x0392
+#define MOD_ID_IMX412           0x0412
+#define MOD_ID_IMX415           0x0415
+#define MOD_ID_IMX568           0x0568
+#define MOD_ID_OV7251           0x7251
+#define MOD_ID_OV9281           0x9281
+
+int vc_mod_is_color_sensor(struct vc_desc *desc);
+int vc_mod_ctrl_init(struct vc_ctrl* ctrl, struct vc_desc* desc);
+
+#endif // _VC_MIPI_MODULES_H
-- 
2.25.1

